"""
AI-Enhanced Business Logic for CRM Service v2 E-commerce
========================================================

Advanced business logic implementations with AI integration for:
- Cross-selling and upselling recommendations
- Dynamic pricing optimization
- Automated inventory management
- Customer segmentation and targeting
- Fraud prevention and risk assessment
"""

import logging
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta, date
from decimal import Decimal
import asyncio
import statistics
from models.ecommerce import (
    Product, Order, OrderItem, InventoryLevel, ProductClassification,
    FraudRiskLevel, ProductCategory, OrderStatus, ProductStatus
)

logger = logging.getLogger(__name__)

class CrossSellingEngine:
    """AI-powered cross-selling and upselling recommendations"""
    
    def __init__(self):
        self.category_affinity = {
            ProductCategory.FITNESS: [ProductCategory.HEALTH, ProductCategory.WELLNESS],
            ProductCategory.HEALTH: [ProductCategory.WELLNESS, ProductCategory.FITNESS],
            ProductCategory.WELLNESS: [ProductCategory.HEALTH, ProductCategory.FITNESS],
            ProductCategory.SPORTS: [ProductCategory.FITNESS, ProductCategory.HEALTH]
        }
        
        self.price_multipliers = {
            "upsell": (1.2, 3.0),  # 20% to 300% more expensive
            "cross_sell": (0.5, 2.0),  # 50% cheaper to 200% more expensive
            "complement": (0.3, 1.5)   # 70% cheaper to 50% more expensive
        }
    
    async def generate_product_recommendations(
        self, 
        product: Product, 
        products_db: Dict[str, Product],
        recommendation_type: str = "cross_sell",
        limit: int = 10
    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate AI-powered product recommendations\"\"\"\n        try:\n            recommendations = []\n            \n            # Get products in same tenant\n            tenant_products = [\n                p for p in products_db.values() \n                if p.tenant_id == product.tenant_id and p.id != product.id and p.status == ProductStatus.ACTIVE\n            ]\n            \n            if recommendation_type == "upsell":\n                recommendations = await self._generate_upsell_recommendations(\n                    product, tenant_products, limit\n                )\n            elif recommendation_type == "cross_sell":\n                recommendations = await self._generate_cross_sell_recommendations(\n                    product, tenant_products, limit\n                )\n            elif recommendation_type == "complement":\n                recommendations = await self._generate_complement_recommendations(\n                    product, tenant_products, limit\n                )\n            \n            # Sort by confidence score\n            recommendations.sort(key=lambda x: x["confidence"], reverse=True)\n            return recommendations[:limit]\n            \n        except Exception as e:\n            logger.error(f"Product recommendation generation failed: {e}")\n            return []\n    \n    async def _generate_upsell_recommendations(\n        self, \n        product: Product, \n        candidate_products: List[Product], \n        limit: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate upselling recommendations (higher-tier products)\"\"\"\n        min_price, max_price = self.price_multipliers["upsell"]\n        target_min = product.pricing.source_price * min_price\n        target_max = product.pricing.source_price * max_price\n        \n        upsell_candidates = [\n            p for p in candidate_products\n            if (target_min <= p.pricing.source_price <= target_max and \n                p.category == product.category and\n                self._is_better_classification(p.ai_metrics.classification if p.ai_metrics else None,\n                                               product.ai_metrics.classification if product.ai_metrics else None))\n        ]\n        \n        recommendations = []\n        for candidate in upsell_candidates:\n            confidence = self._calculate_upsell_confidence(product, candidate)\n            recommendations.append({\n                "product_id": candidate.id,\n                "title": candidate.title,\n                "price": candidate.pricing.source_price,\n                "category": candidate.category.value,\n                "classification": candidate.ai_metrics.classification.value if candidate.ai_metrics else "unknown",\n                "recommendation_type": "upsell",\n                "confidence": confidence,\n                "reason": f"Premium alternative in {candidate.category.value} category",\n                "price_difference": candidate.pricing.source_price - product.pricing.source_price,\n                "value_proposition": "Higher quality and better features"\n            })\n        \n        return recommendations\n    \n    async def _generate_cross_sell_recommendations(\n        self, \n        product: Product, \n        candidate_products: List[Product], \n        limit: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate cross-selling recommendations (related categories)\"\"\"\n        related_categories = self.category_affinity.get(product.category, [])\n        min_price, max_price = self.price_multipliers["cross_sell"]\n        target_min = product.pricing.source_price * min_price\n        target_max = product.pricing.source_price * max_price\n        \n        cross_sell_candidates = [\n            p for p in candidate_products\n            if (p.category in related_categories and\n                target_min <= p.pricing.source_price <= target_max)\n        ]\n        \n        recommendations = []\n        for candidate in cross_sell_candidates:\n            confidence = self._calculate_cross_sell_confidence(product, candidate)\n            recommendations.append({\n                "product_id": candidate.id,\n                "title": candidate.title,\n                "price": candidate.pricing.source_price,\n                "category": candidate.category.value,\n                "classification": candidate.ai_metrics.classification.value if candidate.ai_metrics else "unknown",\n                "recommendation_type": "cross_sell",\n                "confidence": confidence,\n                "reason": f"Complements your {product.category.value} interest",\n                "category_affinity": f"{product.category.value} + {candidate.category.value}",\n                "bundle_potential": "High"\n            })\n        \n        return recommendations\n    \n    async def _generate_complement_recommendations(\n        self, \n        product: Product, \n        candidate_products: List[Product], \n        limit: int\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Generate complementary product recommendations (accessories, add-ons)\"\"\"\n        min_price, max_price = self.price_multipliers["complement"]\n        target_max = product.pricing.source_price * max_price\n        \n        # Look for lower-priced items in same or related categories\n        complement_candidates = [\n            p for p in candidate_products\n            if (p.pricing.source_price <= target_max and\n                (p.category == product.category or \n                 p.category in self.category_affinity.get(product.category, [])))\n        ]\n        \n        recommendations = []\n        for candidate in complement_candidates:\n            confidence = self._calculate_complement_confidence(product, candidate)\n            recommendations.append({\n                "product_id": candidate.id,\n                "title": candidate.title,\n                "price": candidate.pricing.source_price,\n                "category": candidate.category.value,\n                "classification": candidate.ai_metrics.classification.value if candidate.ai_metrics else "unknown",\n                "recommendation_type": "complement",\n                "confidence": confidence,\n                "reason": f"Perfect add-on for {product.category.value} products",\n                "bundle_discount_potential": "15-25%",\n                "order_frequency": "Often bought together"\n            })\n        \n        return recommendations\n    \n    def _is_better_classification(self, candidate_class: Optional[ProductClassification], current_class: Optional[ProductClassification]) -> bool:\n        \"\"\"Check if candidate has better classification than current product\"\"\"\n        if not candidate_class or not current_class:\n            return False\n            \n        class_hierarchy = {\n            ProductClassification.HERO: 4,\n            ProductClassification.GOOD: 3,\n            ProductClassification.MODERATE: 2,\n            ProductClassification.POOR: 1\n        }\n        \n        return class_hierarchy.get(candidate_class, 0) > class_hierarchy.get(current_class, 0)\n    \n    def _calculate_upsell_confidence(self, base_product: Product, candidate: Product) -> float:\n        \"\"\"Calculate confidence score for upselling\"\"\"\n        confidence = 0.5  # Base confidence\n        \n        # Same category boost\n        if candidate.category == base_product.category:\n            confidence += 0.2\n        \n        # Classification boost\n        if (candidate.ai_metrics and base_product.ai_metrics and\n            self._is_better_classification(candidate.ai_metrics.classification, \n                                         base_product.ai_metrics.classification)):\n            confidence += 0.15\n        \n        # Price ratio consideration\n        price_ratio = candidate.pricing.source_price / base_product.pricing.source_price\n        if 1.2 <= price_ratio <= 2.0:  # Sweet spot for upselling\n            confidence += 0.1\n        \n        # Brand consideration\n        if candidate.brand and base_product.brand and candidate.brand == base_product.brand:\n            confidence += 0.05\n        \n        return min(confidence, 1.0)\n    \n    def _calculate_cross_sell_confidence(self, base_product: Product, candidate: Product) -> float:\n        \"\"\"Calculate confidence score for cross-selling\"\"\"\n        confidence = 0.4  # Base confidence\n        \n        # Category affinity\n        if candidate.category in self.category_affinity.get(base_product.category, []):\n            confidence += 0.25\n        \n        # Price similarity\n        price_ratio = candidate.pricing.source_price / base_product.pricing.source_price\n        if 0.7 <= price_ratio <= 1.5:  # Similar price range\n            confidence += 0.15\n        \n        # Classification matching\n        if (candidate.ai_metrics and base_product.ai_metrics and\n            candidate.ai_metrics.classification == base_product.ai_metrics.classification):\n            confidence += 0.1\n        \n        return min(confidence, 1.0)\n    \n    def _calculate_complement_confidence(self, base_product: Product, candidate: Product) -> float:\n        \"\"\"Calculate confidence score for complementary products\"\"\"\n        confidence = 0.6  # Higher base for complements\n        \n        # Lower price boost (accessories are usually cheaper)\n        if candidate.pricing.source_price < base_product.pricing.source_price:\n            confidence += 0.1\n        \n        # Same category boost\n        if candidate.category == base_product.category:\n            confidence += 0.15\n        \n        return min(confidence, 1.0)\n\nclass DynamicPricingEngine:\n    \"\"\"AI-powered dynamic pricing optimization\"\"\"\n    \n    def __init__(self):\n        self.classification_multipliers = {\n            ProductClassification.HERO: 1.25,    # 25% premium\n            ProductClassification.GOOD: 1.15,    # 15% premium  \n            ProductClassification.MODERATE: 1.05,  # 5% premium\n            ProductClassification.POOR: 0.95      # 5% discount\n        }\n        \n        self.demand_multipliers = {\n            "high": 1.1,    # 10% increase for high demand\n            "medium": 1.0,  # No change\n            "low": 0.9      # 10% decrease for low demand\n        }\n    \n    async def calculate_optimal_price(\n        self, \n        product: Product, \n        market_conditions: Dict[str, Any],\n        competitor_prices: List[float] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Calculate optimal selling price using AI algorithms\"\"\"\n        try:\n            base_price = product.pricing.source_price\n            current_price = product.pricing.current_selling_price or base_price\n            \n            # Start with base price plus margin\n            target_margin = 0.25  # 25% default margin\n            if product.ai_metrics:\n                target_margin = product.ai_metrics.profit_margin_estimate\n            \n            optimal_price = base_price * (1 + target_margin)\n            \n            # Apply classification multiplier\n            if product.ai_metrics and product.ai_metrics.classification:\n                class_multiplier = self.classification_multipliers.get(\n                    product.ai_metrics.classification, 1.0\n                )\n                optimal_price *= class_multiplier\n            \n            # Apply market demand adjustment\n            demand_level = market_conditions.get("demand_level", "medium")\n            demand_multiplier = self.demand_multipliers.get(demand_level, 1.0)\n            optimal_price *= demand_multiplier\n            \n            # Competitive pricing adjustment\n            if competitor_prices:\n                avg_competitor_price = statistics.mean(competitor_prices)\n                competitive_position = self._calculate_competitive_position(\n                    optimal_price, avg_competitor_price\n                )\n                optimal_price = self._adjust_for_competition(\n                    optimal_price, avg_competitor_price, competitive_position\n                )\n            \n            # Calculate price change recommendation\n            price_change = optimal_price - current_price\n            price_change_percent = (price_change / current_price) * 100\n            \n            return {\n                "product_id": product.id,\n                "current_price": current_price,\n                "recommended_price": round(optimal_price, 2),\n                "price_change": round(price_change, 2),\n                "price_change_percent": round(price_change_percent, 2),\n                "target_margin": target_margin,\n                "classification_impact": self.classification_multipliers.get(\n                    product.ai_metrics.classification if product.ai_metrics else ProductClassification.MODERATE, 1.0\n                ),\n                "market_demand_impact": demand_multiplier,\n                "competitive_position": self._get_price_position(optimal_price, competitor_prices) if competitor_prices else "unknown",\n                "confidence": self._calculate_pricing_confidence(product, market_conditions),\n                "recommendation": self._get_pricing_recommendation(price_change_percent),\n                "calculated_at": datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            logger.error(f"Pricing calculation failed: {e}")\n            return {\n                "error": str(e),\n                "recommended_price": product.pricing.current_selling_price or product.pricing.source_price\n            }\n    \n    def _calculate_competitive_position(self, our_price: float, avg_competitor_price: float) -> str:\n        \"\"\"Determine competitive position\"\"\"\n        ratio = our_price / avg_competitor_price\n        \n        if ratio <= 0.9:\n            return "aggressive"\n        elif ratio <= 1.1:\n            return "competitive"\n        elif ratio <= 1.3:\n            return "premium"\n        else:\n            return "luxury"\n    \n    def _adjust_for_competition(self, optimal_price: float, avg_competitor_price: float, position: str) -> float:\n        \"\"\"Adjust price based on competitive position\"\"\"\n        if position == "aggressive":\n            # Don't go too low\n            return max(optimal_price, avg_competitor_price * 0.85)\n        elif position == "luxury":\n            # Ensure we're providing value\n            return min(optimal_price, avg_competitor_price * 1.4)\n        else:\n            return optimal_price\n    \n    def _get_price_position(self, our_price: float, competitor_prices: List[float]) -> str:\n        \"\"\"Get price position relative to competitors\"\"\"\n        if not competitor_prices:\n            return "unknown"\n            \n        min_price = min(competitor_prices)\n        max_price = max(competitor_prices)\n        avg_price = statistics.mean(competitor_prices)\n        \n        if our_price <= min_price:\n            return "lowest"\n        elif our_price >= max_price:\n            return "highest"\n        elif our_price <= avg_price:\n            return "below_average"\n        else:\n            return "above_average"\n    \n    def _calculate_pricing_confidence(self, product: Product, market_conditions: Dict[str, Any]) -> float:\n        \"\"\"Calculate confidence in pricing recommendation\"\"\"\n        confidence = 0.7  # Base confidence\n        \n        # Higher confidence for classified products\n        if product.ai_metrics and product.ai_metrics.classification != ProductClassification.POOR:\n            confidence += 0.1\n        \n        # Market data availability\n        if market_conditions.get("demand_level"):\n            confidence += 0.1\n        \n        # Historical data (simulated)\n        confidence += 0.1\n        \n        return min(confidence, 1.0)\n    \n    def _get_pricing_recommendation(self, price_change_percent: float) -> str:\n        \"\"\"Get pricing action recommendation\"\"\"\n        if abs(price_change_percent) < 2:\n            return "maintain_current_price"\n        elif price_change_percent > 10:\n            return "increase_gradually"\n        elif price_change_percent > 0:\n            return "increase_price"\n        elif price_change_percent < -10:\n            return "decrease_gradually" \n        else:\n            return "decrease_price"\n\nclass InventoryOptimizer:\n    \"\"\"AI-powered inventory optimization\"\"\"\n    \n    def __init__(self):\n        self.safety_stock_multiplier = 1.5\n        self.seasonality_factors = {\n            "fitness": {1: 1.5, 2: 1.2, 3: 1.0, 6: 1.3, 7: 1.1},  # January surge, summer prep\n            "health": {10: 1.2, 11: 1.3, 12: 1.1, 1: 1.4},         # Winter wellness\n            "wellness": {1: 1.3, 9: 1.2, 12: 1.1},                 # New Year, back-to-school\n            "sports": {4: 1.2, 5: 1.4, 6: 1.3, 7: 1.2, 8: 1.1}    # Spring/summer outdoor\n        }\n    \n    async def calculate_optimal_stock_levels(\n        self, \n        product: Product, \n        inventory: InventoryLevel,\n        sales_history: List[Dict[str, Any]] = None\n    ) -> Dict[str, Any]:\n        \"\"\"Calculate optimal inventory levels using AI\"\"\"\n        try:\n            # Estimate daily sales velocity\n            daily_velocity = self._estimate_daily_velocity(product, sales_history)\n            \n            # Calculate lead time (days to restock)\n            lead_time = self._estimate_lead_time(product)\n            \n            # Apply seasonality\n            current_month = datetime.now().month\n            seasonal_factor = self._get_seasonal_factor(product.category.value, current_month)\n            \n            # Calculate optimal levels\n            safety_stock = int(daily_velocity * lead_time * self.safety_stock_multiplier)\n            reorder_point = int((daily_velocity * lead_time) + safety_stock)\n            economic_order_quantity = int(self._calculate_eoq(daily_velocity, product))\n            \n            # Apply seasonal adjustment\n            seasonal_reorder_point = int(reorder_point * seasonal_factor)\n            seasonal_order_quantity = int(economic_order_quantity * seasonal_factor)\n            \n            # Stock status assessment\n            current_stock = inventory.available_quantity\n            days_of_stock = current_stock / daily_velocity if daily_velocity > 0 else float('inf')\n            \n            return {\n                "product_id": product.id,\n                "current_stock": current_stock,\n                "daily_velocity": round(daily_velocity, 2),\n                "lead_time_days": lead_time,\n                "safety_stock": safety_stock,\n                "reorder_point": seasonal_reorder_point,\n                "economic_order_quantity": seasonal_order_quantity,\n                "days_of_stock_remaining": round(days_of_stock, 1),\n                "seasonal_factor": seasonal_factor,\n                "stock_status": self._get_stock_status(current_stock, seasonal_reorder_point),\n                "recommended_action": self._get_inventory_action(\n                    current_stock, seasonal_reorder_point, days_of_stock\n                ),\n                "confidence": self._calculate_inventory_confidence(sales_history),\n                "calculated_at": datetime.now().isoformat()\n            }\n            \n        except Exception as e:\n            logger.error(f"Inventory optimization failed: {e}")\n            return {"error": str(e)}\n    \n    def _estimate_daily_velocity(self, product: Product, sales_history: List[Dict[str, Any]] = None) -> float:\n        \"\"\"Estimate daily sales velocity\"\"\"\n        if sales_history:\n            # Use actual sales data\n            total_sold = sum(sale.get("quantity", 0) for sale in sales_history)\n            days_span = len(sales_history) if sales_history else 30\n            return total_sold / days_span\n        else:\n            # Estimate based on classification and category\n            base_velocity = {\n                ProductClassification.HERO: 5.0,\n                ProductClassification.GOOD: 3.0,\n                ProductClassification.MODERATE: 1.5,\n                ProductClassification.POOR: 0.5\n            }\n            \n            if product.ai_metrics and product.ai_metrics.classification:\n                return base_velocity.get(product.ai_metrics.classification, 1.0)\n            else:\n                return 1.0\n    \n    def _estimate_lead_time(self, product: Product) -> int:\n        \"\"\"Estimate supplier lead time\"\"\"\n        # Default lead times by marketplace\n        lead_times = {\n            "amazon": 3,\n            "flipkart": 5,\n            "indiamart": 7,\n            "etsy": 10,\n            "overstock": 5\n        }\n        \n        return lead_times.get(product.source_marketplace.value, 7)\n    \n    def _get_seasonal_factor(self, category: str, month: int) -> float:\n        \"\"\"Get seasonal adjustment factor\"\"\"\n        category_seasonality = self.seasonality_factors.get(category, {})\n        return category_seasonality.get(month, 1.0)\n    \n    def _calculate_eoq(self, daily_velocity: float, product: Product) -> float:\n        \"\"\"Calculate Economic Order Quantity (simplified)\"\"\"\n        annual_demand = daily_velocity * 365\n        ordering_cost = 50  # Fixed cost per order\n        holding_cost_rate = 0.2  # 20% of product cost per year\n        holding_cost = product.pricing.source_price * holding_cost_rate\n        \n        # EOQ formula: sqrt(2 * demand * ordering_cost / holding_cost)\n        import math\n        return math.sqrt(2 * annual_demand * ordering_cost / holding_cost) if holding_cost > 0 else 50\n    \n    def _get_stock_status(self, current_stock: int, reorder_point: int) -> str:\n        \"\"\"Determine stock status\"\"\"\n        if current_stock <= 0:\n            return "out_of_stock"\n        elif current_stock <= reorder_point * 0.5:\n            return "critical"\n        elif current_stock <= reorder_point:\n            return "low"\n        elif current_stock <= reorder_point * 2:\n            return "normal"\n        else:\n            return "high"\n    \n    def _get_inventory_action(self, current_stock: int, reorder_point: int, days_of_stock: float) -> str:\n        \"\"\"Get recommended inventory action\"\"\"\n        if current_stock <= 0:\n            return "emergency_reorder"\n        elif current_stock <= reorder_point:\n            return "reorder_now"\n        elif days_of_stock < 7:\n            return "prepare_reorder"\n        else:\n            return "monitor"\n    \n    def _calculate_inventory_confidence(self, sales_history: List[Dict[str, Any]] = None) -> float:\n        \"\"\"Calculate confidence in inventory recommendations\"\"\"\n        if sales_history and len(sales_history) > 30:\n            return 0.9  # High confidence with good historical data\n        elif sales_history and len(sales_history) > 7:\n            return 0.7  # Medium confidence\n        else:\n            return 0.5  # Low confidence without historical data\n\n# Global instances\ncross_selling_engine = CrossSellingEngine()\ndynamic_pricing_engine = DynamicPricingEngine()\ninventory_optimizer = InventoryOptimizer()\n\n# Export public interface\n__all__ = [\n    "CrossSellingEngine",\n    "DynamicPricingEngine", \n    "InventoryOptimizer",\n    "cross_selling_engine",\n    "dynamic_pricing_engine",\n    "inventory_optimizer"\n]