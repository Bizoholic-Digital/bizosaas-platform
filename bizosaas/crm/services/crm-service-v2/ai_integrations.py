"""
AI Agent Integration Module for CRM Service v2
==============================================

Integration layer for connecting CRM service with existing AI agents:
- Marketing Ecosystem Orchestrator 
- Product Sourcing Crew
- Classification Crew
- Analytics Specialist

This module provides seamless integration with the existing CrewAI agents
while maintaining proper error handling and async operations.
"""

import logging
import asyncio
import os
import json
from typing import Dict, Any, List, Optional, Union
from datetime import datetime, timedelta
import requests
from models.ecommerce import (
    Product, Order, ProductClassification, FraudRiskLevel,
    ProductAIMetrics, FraudDetectionMetrics, ProductMarketData,
    AIWorkflowExecution
)

logger = logging.getLogger(__name__)

class AIAgentClient:
    """Client for communicating with existing AI agents"""
    
    def __init__(self):
        self.crewai_host = os.getenv("CREWAI_HOST", "localhost")
        self.crewai_port = os.getenv("CREWAI_PORT", "8000")
        self.base_url = f"http://{self.crewai_host}:{self.crewai_port}"
        self.timeout = 30
        
    async def health_check(self) -> bool:
        """Check if AI agents are available"""
        try:
            response = requests.get(f"{self.base_url}/health", timeout=self.timeout)
            return response.status_code == 200
        except Exception as e:
            logger.error(f"AI agent health check failed: {e}")
            return False

class ProductClassificationAgent:
    """Integration with Classification Crew for product analysis"""
    
    def __init__(self, client: AIAgentClient):
        self.client = client
        
    async def classify_product(self, product: Product) -> ProductAIMetrics:
        """
        Classify product using the existing Classification Crew
        """
        try:
            # Prepare product data for classification
            product_data = {
                "title": product.title,
                "description": product.description or "",
                "price": product.pricing.source_price,
                "category": product.category.value,
                "brand": product.brand or "",
                "asin": product.asin,
                "features": product.key_features,
                "specifications": product.specifications
            }
            
            # Call Classification Crew endpoint
            response = await self._call_classification_api(product_data)
            
            if response and "classification" in response:
                return ProductAIMetrics(
                    dropship_score=float(response.get("dropship_score", 0.0)),
                    classification=ProductClassification(response["classification"]),
                    eligibility_factors=response.get("eligibility_factors", []),
                    profit_margin_estimate=float(response.get("profit_margin", 0.25)),\n                    ai_workflow_id=response.get("workflow_id")\n                )\n            else:\n                # Fallback to basic classification\n                return self._basic_classification(product)\n                \n        except Exception as e:\n            logger.error(f"Product classification failed: {e}")\n            return self._basic_classification(product)\n    \n    async def _call_classification_api(self, product_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Call the classification API endpoint"""\n        try:\n            url = f"{self.client.base_url}/agents/product-classification"\n            \n            # Make async HTTP request\n            loop = asyncio.get_event_loop()\n            response = await loop.run_in_executor(\n                None,\n                lambda: requests.post(\n                    url, \n                    json=product_data, \n                    timeout=self.client.timeout\n                )\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                logger.warning(f"Classification API returned {response.status_code}")\n                return None\n                \n        except Exception as e:\n            logger.error(f"Classification API call failed: {e}")\n            return None\n    \n    def _basic_classification(self, product: Product) -> ProductAIMetrics:\n        """Fallback basic classification logic"""\n        score = 50  # Base score\n        factors = ["basic_analysis"]\n        \n        # Price-based scoring\n        if 20 <= product.pricing.source_price <= 100:\n            score += 15\n            factors.append("optimal_price_range")\n        elif product.pricing.source_price > 100:\n            score += 5\n            factors.append("premium_pricing")\n        \n        # Category scoring\n        high_demand_categories = [\"fitness", "health", "wellness"]\n        if product.category.value in high_demand_categories:\n            score += 20\n            factors.append("high_demand_category")\n        \n        # Brand scoring\n        if product.brand and len(product.brand) > 0:\n            score += 10\n            factors.append("branded_product")\n        \n        # Feature scoring\n        if len(product.key_features) >= 3:\n            score += 5\n            factors.append("detailed_features")\n        \n        # Determine classification\n        if score >= 80:\n            classification = ProductClassification.HERO\n        elif score >= 65:\n            classification = ProductClassification.GOOD\n        elif score >= 40:\n            classification = ProductClassification.MODERATE\n        else:\n            classification = ProductClassification.POOR\n        \n        return ProductAIMetrics(\n            dropship_score=float(min(score, 100)),\n            classification=classification,\n            eligibility_factors=factors,\n            profit_margin_estimate=0.25\n        )

class ProductSourcingAgent:\n    """Integration with Product Sourcing Crew for product discovery and analysis"""\n    \n    def __init__(self, client: AIAgentClient):\n        self.client = client\n    \n    async def analyze_market_opportunity(self, product: Product) -> ProductMarketData:\n        """Analyze market opportunity using Product Sourcing Crew"""\n        try:\n            # Prepare data for market analysis\n            analysis_data = {\n                "category": product.category.value,\n                "price_range": {\n                    "min": product.pricing.source_price * 0.8,\n                    "max": product.pricing.source_price * 1.2\n                },\n                "product_title": product.title,\n                "brand": product.brand\n            }\n            \n            # Call Product Sourcing API\n            response = await self._call_sourcing_api(analysis_data)\n            \n            if response:\n                return ProductMarketData(\n                    market_opportunity=response.get("opportunity_level", "medium"),\n                    trending_score=float(response.get("trending_score", 0.5)),\n                    seasonal_factors=response.get("seasonal_factors", []),\n                    competitive_analysis=response.get("competitive_analysis", {}),\n                    estimated_monthly_sales=int(response.get("estimated_sales", 100))\n                )\n            else:\n                return self._basic_market_analysis(product)\n                \n        except Exception as e:\n            logger.error(f"Market opportunity analysis failed: {e}")\n            return self._basic_market_analysis(product)\n    \n    async def get_product_recommendations(self, tenant_id: int, category: str, limit: int = 10) -> List[Dict[str, Any]]:\n        """Get AI product recommendations from sourcing crew"""\n        try:\n            request_data = {\n                "tenant_id": tenant_id,\n                "categories": [category],\n                "max_products": limit\n            }\n            \n            response = await self._call_sourcing_api(request_data, endpoint="product-discovery")\n            return response.get("recommended_products", []) if response else []\n            \n        except Exception as e:\n            logger.error(f"Product recommendations failed: {e}")\n            return []\n    \n    async def _call_sourcing_api(self, data: Dict[str, Any], endpoint: str = "market-analysis") -> Optional[Dict[str, Any]]:\n        """Call the Product Sourcing Crew API"""\n        try:\n            url = f"{self.client.base_url}/agents/sourcing/{endpoint}"\n            \n            loop = asyncio.get_event_loop()\n            response = await loop.run_in_executor(\n                None,\n                lambda: requests.post(url, json=data, timeout=self.client.timeout)\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                logger.warning(f"Sourcing API returned {response.status_code}")\n                return None\n                \n        except Exception as e:\n            logger.error(f"Sourcing API call failed: {e}")\n            return None\n    \n    def _basic_market_analysis(self, product: Product) -> ProductMarketData:\n        """Fallback basic market analysis"""\n        # Simple market scoring based on category\n        trending_scores = {\n            "fitness": 0.8,\n            "health": 0.75,\n            "wellness": 0.7,\n            "sports": 0.65\n        }\n        \n        seasonal_factors_map = {\n            "fitness": ["january_surge", "summer_prep"],\n            "health": ["winter_wellness", "spring_detox"],\n            "wellness": ["stress_season", "holiday_recovery"],\n            "sports": ["summer_outdoor", "winter_indoor"]\n        }\n        \n        return ProductMarketData(\n            market_opportunity="medium",\n            trending_score=trending_scores.get(product.category.value, 0.5),\n            seasonal_factors=seasonal_factors_map.get(product.category.value, []),\n            competitive_analysis={"competition_level": "medium"},\n            estimated_monthly_sales=150\n        )

class MarketingEcosystemAgent:\n    """Integration with Marketing Ecosystem Orchestrator"""\n    \n    def __init__(self, client: AIAgentClient):\n        self.client = client\n    \n    async def generate_marketing_strategy(self, product: Product) -> Dict[str, Any]:\n        """Generate marketing strategy using Marketing Ecosystem"""\n        try:\n            strategy_data = {\n                "product": {\n                    "title": product.title,\n                    "category": product.category.value,\n                    "price": product.pricing.source_price,\n                    "classification": product.ai_metrics.classification.value if product.ai_metrics else "moderate"\n                }\n            }\n            \n            response = await self._call_marketing_api(strategy_data)\n            \n            if response:\n                return {\n                    "marketing_channels": response.get("channels", []),\n                    "target_demographics": response.get("demographics", []),\n                    "messaging_strategy": response.get("messaging", {}),\n                    "budget_allocation": response.get("budget", {}),\n                    "campaign_timeline": response.get("timeline", {})\n                }\n            else:\n                return self._basic_marketing_strategy(product)\n                \n        except Exception as e:\n            logger.error(f"Marketing strategy generation failed: {e}")\n            return self._basic_marketing_strategy(product)\n    \n    async def _call_marketing_api(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Call Marketing Ecosystem API"""\n        try:\n            url = f"{self.client.base_url}/agents/marketing/strategy"\n            \n            loop = asyncio.get_event_loop()\n            response = await loop.run_in_executor(\n                None,\n                lambda: requests.post(url, json=data, timeout=self.client.timeout)\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                logger.warning(f"Marketing API returned {response.status_code}")\n                return None\n                \n        except Exception as e:\n            logger.error(f"Marketing API call failed: {e}")\n            return None\n    \n    def _basic_marketing_strategy(self, product: Product) -> Dict[str, Any]:\n        """Fallback basic marketing strategy"""\n        category_strategies = {\n            "fitness": {\n                "channels": ["instagram", "youtube", "fitness_blogs"],\n                "demographics": ["fitness_enthusiasts", "health_conscious"],\n                "messaging": {"tone": "motivational", "focus": "results"}\n            },\n            "health": {\n                "channels": ["facebook", "health_forums", "email"],\n                "demographics": ["health_seekers", "wellness_focused"],\n                "messaging": {"tone": "informative", "focus": "benefits"}\n            }\n        }\n        \n        return category_strategies.get(product.category.value, {\n            "channels": ["social_media", "email"],\n            "demographics": ["general_consumers"],\n            "messaging": {"tone": "friendly", "focus": "value"}\n        })

class FraudDetectionAgent:\n    """AI-powered fraud detection for orders"""\n    \n    def __init__(self, client: AIAgentClient):\n        self.client = client\n    \n    async def analyze_order_fraud_risk(self, order: Order) -> FraudDetectionMetrics:\n        """Analyze order for fraud risk using AI"""\n        try:\n            order_data = {\n                "order_amount": float(order.total_amount),\n                "item_count": len(order.items),\n                "customer_email": order.customer_email,\n                "shipping_address": order.shipping_address.dict(),\n                "billing_address": order.billing_address.dict() if order.billing_address else None,\n                "items": [{\n                    "price": item.unit_price,\n                    "quantity": item.quantity,\n                    "total": item.total_price\n                } for item in order.items]\n            }\n            \n            # Call fraud detection API (if available)\n            response = await self._call_fraud_api(order_data)\n            \n            if response:\n                return FraudDetectionMetrics(\n                    risk_level=FraudRiskLevel(response["risk_level"]),\n                    risk_score=float(response["risk_score"]),\n                    risk_factors=response.get("risk_factors", []),\n                    verification_required=response.get("verification_required", False),\n                    confidence=float(response.get("confidence", 0.8))\n                )\n            else:\n                return self._basic_fraud_analysis(order)\n                \n        except Exception as e:\n            logger.error(f"Fraud detection failed: {e}")\n            return self._basic_fraud_analysis(order)\n    \n    async def _call_fraud_api(self, data: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        """Call fraud detection API"""\n        try:\n            url = f"{self.client.base_url}/agents/fraud-detection"\n            \n            loop = asyncio.get_event_loop()\n            response = await loop.run_in_executor(\n                None,\n                lambda: requests.post(url, json=data, timeout=self.client.timeout)\n            )\n            \n            if response.status_code == 200:\n                return response.json()\n            else:\n                logger.warning(f"Fraud API returned {response.status_code}")\n                return None\n                \n        except Exception as e:\n            logger.error(f"Fraud API call failed: {e}")\n            return None\n    \n    def _basic_fraud_analysis(self, order: Order) -> FraudDetectionMetrics:\n        """Basic fraud detection logic"""\n        risk_score = 0.0\n        risk_factors = []\n        \n        # High order value check\n        if order.total_amount > 1000:\n            risk_score += 0.3\n            risk_factors.append("high_order_value")\n        elif order.total_amount > 500:\n            risk_score += 0.1\n            risk_factors.append("elevated_order_value")\n        \n        # Item quantity check\n        total_items = sum(item.quantity for item in order.items)\n        if total_items > 10:\n            risk_score += 0.2\n            risk_factors.append("high_item_quantity")\n        \n        # Address mismatch check\n        if order.billing_address and order.billing_address != order.shipping_address:\n            risk_score += 0.1\n            risk_factors.append("address_mismatch")\n        \n        # Determine risk level\n        if risk_score >= 0.7:\n            risk_level = FraudRiskLevel.CRITICAL\n        elif risk_score >= 0.4:\n            risk_level = FraudRiskLevel.HIGH\n        elif risk_score >= 0.2:\n            risk_level = FraudRiskLevel.MEDIUM\n        else:\n            risk_level = FraudRiskLevel.LOW\n        \n        return FraudDetectionMetrics(\n            risk_level=risk_level,\n            risk_score=min(risk_score, 1.0),\n            risk_factors=risk_factors,\n            verification_required=risk_score >= 0.4,\n            confidence=0.75\n        )

# Global AI integration instances
ai_client = AIAgentClient()
product_classifier = ProductClassificationAgent(ai_client)
product_sourcing = ProductSourcingAgent(ai_client)
marketing_ecosystem = MarketingEcosystemAgent(ai_client)
fraud_detector = FraudDetectionAgent(ai_client)

# Helper functions for main.py integration
async def classify_product_with_ai(product: Product) -> Product:
    """Enhanced product classification using actual AI agents"""\n    try:\n        # Get AI classification\n        ai_metrics = await product_classifier.classify_product(product)\n        product.ai_metrics = ai_metrics\n        \n        # Get market analysis\n        market_data = await product_sourcing.analyze_market_opportunity(product)\n        product.market_data = market_data\n        \n        logger.info(f\"AI classification completed: {product.title} -> {ai_metrics.classification.value}\")\n        return product\n        \n    except Exception as e:\n        logger.error(f"AI product classification failed: {e}")\n        return product

async def detect_fraud_with_ai(order: Order) -> Order:\n    """Enhanced fraud detection using AI agents"""\n    try:\n        fraud_analysis = await fraud_detector.analyze_order_fraud_risk(order)\n        order.fraud_analysis = fraud_analysis\n        \n        logger.info(f\"Fraud analysis completed: {order.order_number} -> {fraud_analysis.risk_level.value}\")\n        return order\n        \n    except Exception as e:\n        logger.error(f\"AI fraud detection failed: {e}")\n        return order\n\nasync def get_ai_product_recommendations(tenant_id: int, category: str, limit: int = 10) -> List[Dict[str, Any]]:\n    """Get AI-powered product recommendations"""\n    try:\n        recommendations = await product_sourcing.get_product_recommendations(tenant_id, category, limit)\n        logger.info(f\"Generated {len(recommendations)} product recommendations for category: {category}\")\n        return recommendations\n    except Exception as e:\n        logger.error(f\"AI product recommendations failed: {e}\")\n        return []\n\nasync def generate_marketing_strategy(product: Product) -> Dict[str, Any]:\n    """Generate AI-powered marketing strategy"""\n    try:\n        strategy = await marketing_ecosystem.generate_marketing_strategy(product)\n        logger.info(f\"Marketing strategy generated for: {product.title}\")\n        return strategy\n    except Exception as e:\n        logger.error(f\"Marketing strategy generation failed: {e}\")\n        return {}\n\nasync def check_ai_agents_health() -> Dict[str, bool]:\n    """Check health of all AI agents"""\n    try:\n        health_status = {\n            "ai_agents_available": await ai_client.health_check(),\n            "classification_ready": True,\n            "sourcing_ready": True,\n            "marketing_ready": True,\n            "fraud_detection_ready": True\n        }\n        return health_status\n    except Exception as e:\n        logger.error(f"AI health check failed: {e}\")\n        return {\n            "ai_agents_available": False,\n            "classification_ready": False,\n            "sourcing_ready": False,\n            "marketing_ready": False,\n            "fraud_detection_ready": False\n        }\n\n# Export public interface\n__all__ = [\n    "classify_product_with_ai",\n    "detect_fraud_with_ai", \n    "get_ai_product_recommendations",\n    "generate_marketing_strategy",\n    "check_ai_agents_health",\n    "product_classifier",\n    "product_sourcing",\n    "marketing_ecosystem", \n    "fraud_detector"\n]