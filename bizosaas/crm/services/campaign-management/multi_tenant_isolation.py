"""
Multi-Tenant Email Campaign Isolation - BizoholicSaaS
Ensures complete isolation of email campaigns, templates, and data between tenants
"""

import uuid
import asyncio
from typing import Dict, Any, List, Optional, Set
from datetime import datetime, timedelta
from enum import Enum
from pydantic import BaseModel, Field
import logging
import json
import hashlib
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class TenantResourceType(str, Enum):
    """Types of tenant-isolated resources"""
    CAMPAIGN = "campaign"
    EMAIL_TEMPLATE = "email_template"
    CONTACT_LIST = "contact_list"
    AUTOMATION_WORKFLOW = "automation_workflow"
    EMAIL_DOMAIN = "email_domain"
    TRACKING_PIXEL = "tracking_pixel"
    UNSUBSCRIBE_PAGE = "unsubscribe_page"
    PREFERENCE_CENTER = "preference_center"

class IsolationLevel(str, Enum):
    """Levels of tenant isolation"""
    STRICT = "strict"         # Complete isolation - no shared resources
    MODERATE = "moderate"     # Shared infrastructure, isolated data
    RELAXED = "relaxed"      # Some shared resources allowed

class TenantTier(str, Enum):
    """Tenant subscription tiers affecting isolation"""
    FREE = "free"
    BASIC = "basic"
    PROFESSIONAL = "professional"
    ENTERPRISE = "enterprise"
    WHITE_LABEL = "white_label"

@dataclass
class TenantConfiguration:
    """Tenant-specific configuration for email campaigns"""
    tenant_id: str
    tier: TenantTier
    isolation_level: IsolationLevel
    custom_domain: Optional[str] = None
    dedicated_ip: Optional[str] = None
    brand_customization: Dict[str, Any] = None
    sending_limits: Dict[str, int] = None
    compliance_settings: Dict[str, Any] = None

class TenantResource(BaseModel):
    """Base model for tenant-isolated resources"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    resource_type: TenantResourceType
    name: str
    data: Dict[str, Any] = {}
    access_permissions: List[str] = []
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
    is_active: bool = True

class TenantEmailDomain(BaseModel):
    """Tenant-specific email domain configuration"""
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    tenant_id: str
    domain: str
    subdomain: Optional[str] = None
    is_verified: bool = False
    dkim_configured: bool = False
    spf_configured: bool = False
    dmarc_configured: bool = False
    reputation_score: float = 0.0
    sending_enabled: bool = False
    daily_limit: int = 1000
    monthly_limit: int = 30000

class TenantContactSegmentation(BaseModel):
    """Tenant contact segmentation and isolation"""
    tenant_id: str
    contact_id: str
    segments: List[str] = []
    tags: List[str] = []
    custom_fields: Dict[str, Any] = {}
    consent_status: Dict[str, bool] = {}
    unsubscribe_groups: List[str] = []
    preferences: Dict[str, Any] = {}

class TenantComplianceSettings(BaseModel):
    """Compliance settings per tenant"""
    tenant_id: str
    gdpr_enabled: bool = False
    ccpa_enabled: bool = False
    can_spam_enabled: bool = True
    double_opt_in_required: bool = False
    unsubscribe_required: bool = True
    data_retention_days: int = 365
    consent_tracking: bool = True
    preference_center_enabled: bool = True

class MultiTenantEmailIsolation:
    """Multi-tenant email campaign isolation manager"""
    
    def __init__(self):
        self.tenant_configs: Dict[str, TenantConfiguration] = {}
        self.tenant_resources: Dict[str, List[TenantResource]] = {}
        self.tenant_domains: Dict[str, List[TenantEmailDomain]] = {}
        self.cross_tenant_access_log: List[Dict[str, Any]] = []
    
    def configure_tenant(self, tenant_id: str, config: Dict[str, Any]) -> TenantConfiguration:
        \"\"\"Configure tenant-specific settings and isolation level\"\"\"\n        \n        tenant_config = TenantConfiguration(\n            tenant_id=tenant_id,\n            tier=TenantTier(config.get(\"tier\", \"basic\")),\n            isolation_level=IsolationLevel(config.get(\"isolation_level\", \"moderate\")),\n            custom_domain=config.get(\"custom_domain\"),\n            dedicated_ip=config.get(\"dedicated_ip\"),\n            brand_customization=config.get(\"brand_customization\", {}),\n            sending_limits=config.get(\"sending_limits\", {\n                \"daily\": 1000,\n                \"monthly\": 30000,\n                \"hourly\": 100\n            }),\n            compliance_settings=config.get(\"compliance_settings\", {})\n        )\n        \n        self.tenant_configs[tenant_id] = tenant_config\n        return tenant_config\n    \n    def create_isolated_resource(self, tenant_id: str, resource_type: TenantResourceType, \n                               resource_data: Dict[str, Any]) -> TenantResource:\n        \"\"\"Create a new tenant-isolated resource\"\"\"\n        \n        # Validate tenant access\n        if not self._validate_tenant_access(tenant_id):\n            raise ValueError(f\"Invalid tenant access: {tenant_id}\")\n        \n        # Create resource with tenant namespace\n        resource = TenantResource(\n            tenant_id=tenant_id,\n            resource_type=resource_type,\n            name=resource_data[\"name\"],\n            data=self._sanitize_resource_data(resource_data, tenant_id),\n            access_permissions=resource_data.get(\"permissions\", [])\n        )\n        \n        # Store in tenant namespace\n        if tenant_id not in self.tenant_resources:\n            self.tenant_resources[tenant_id] = []\n        \n        self.tenant_resources[tenant_id].append(resource)\n        \n        logger.info(f\"Created isolated {resource_type} resource for tenant {tenant_id}\")\n        return resource\n    \n    def get_tenant_resources(self, tenant_id: str, resource_type: Optional[TenantResourceType] = None) -> List[TenantResource]:\n        \"\"\"Get all resources for a tenant, optionally filtered by type\"\"\"\n        \n        if not self._validate_tenant_access(tenant_id):\n            return []\n        \n        tenant_resources = self.tenant_resources.get(tenant_id, [])\n        \n        if resource_type:\n            return [r for r in tenant_resources if r.resource_type == resource_type]\n        \n        return tenant_resources\n    \n    def create_tenant_email_template(self, tenant_id: str, template_data: Dict[str, Any]) -> TenantResource:\n        \"\"\"Create tenant-isolated email template\"\"\"\n        \n        # Add tenant branding\n        tenant_config = self.tenant_configs.get(tenant_id)\n        if tenant_config and tenant_config.brand_customization:\n            template_data = self._apply_tenant_branding(template_data, tenant_config.brand_customization)\n        \n        # Create isolated template\n        return self.create_isolated_resource(\n            tenant_id=tenant_id,\n            resource_type=TenantResourceType.EMAIL_TEMPLATE,\n            resource_data={\n                \"name\": template_data[\"name\"],\n                \"subject\": template_data[\"subject\"],\n                \"html_content\": template_data[\"html_content\"],\n                \"text_content\": template_data.get(\"text_content\"),\n                \"template_variables\": template_data.get(\"template_variables\", []),\n                \"category\": template_data.get(\"category\", \"general\")\n            }\n        )\n    \n    def create_tenant_contact_list(self, tenant_id: str, list_data: Dict[str, Any]) -> TenantResource:\n        \"\"\"Create tenant-isolated contact list\"\"\"\n        \n        # Validate contact data compliance\n        self._validate_contact_compliance(tenant_id, list_data.get(\"contacts\", []))\n        \n        return self.create_isolated_resource(\n            tenant_id=tenant_id,\n            resource_type=TenantResourceType.CONTACT_LIST,\n            resource_data={\n                \"name\": list_data[\"name\"],\n                \"description\": list_data.get(\"description\"),\n                \"contacts\": list_data.get(\"contacts\", []),\n                \"segmentation_rules\": list_data.get(\"segmentation_rules\", {}),\n                \"opt_in_method\": list_data.get(\"opt_in_method\", \"single\"),\n                \"source\": list_data.get(\"source\", \"manual\")\n            }\n        )\n    \n    def setup_tenant_email_domain(self, tenant_id: str, domain_config: Dict[str, Any]) -> TenantEmailDomain:\n        \"\"\"Set up tenant-specific email domain\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        if not tenant_config:\n            raise ValueError(f\"Tenant {tenant_id} not configured\")\n        \n        # Create domain configuration\n        domain = TenantEmailDomain(\n            tenant_id=tenant_id,\n            domain=domain_config[\"domain\"],\n            subdomain=domain_config.get(\"subdomain\"),\n            daily_limit=domain_config.get(\"daily_limit\", tenant_config.sending_limits.get(\"daily\", 1000)),\n            monthly_limit=domain_config.get(\"monthly_limit\", tenant_config.sending_limits.get(\"monthly\", 30000))\n        )\n        \n        # Store domain configuration\n        if tenant_id not in self.tenant_domains:\n            self.tenant_domains[tenant_id] = []\n        \n        self.tenant_domains[tenant_id].append(domain)\n        \n        # Generate DNS configuration instructions\n        dns_config = self._generate_dns_configuration(domain)\n        \n        logger.info(f\"Created email domain configuration for tenant {tenant_id}: {domain.domain}\")\n        \n        return domain\n    \n    def create_tenant_tracking_system(self, tenant_id: str) -> Dict[str, str]:\n        \"\"\"Create tenant-specific tracking system\"\"\"\n        \n        # Generate tenant-specific tracking URLs\n        tracking_domain = self._get_tenant_tracking_domain(tenant_id)\n        \n        tracking_urls = {\n            \"open_tracking\": f\"https://{tracking_domain}/open/{self._generate_tenant_hash(tenant_id)}/{{email_id}}\",\n            \"click_tracking\": f\"https://{tracking_domain}/click/{self._generate_tenant_hash(tenant_id)}/{{link_id}}\",\n            \"unsubscribe\": f\"https://{tracking_domain}/unsubscribe/{self._generate_tenant_hash(tenant_id)}/{{contact_id}}\",\n            \"preference_center\": f\"https://{tracking_domain}/preferences/{self._generate_tenant_hash(tenant_id)}/{{contact_id}}\"\n        }\n        \n        # Create tracking resource\n        self.create_isolated_resource(\n            tenant_id=tenant_id,\n            resource_type=TenantResourceType.TRACKING_PIXEL,\n            resource_data={\n                \"name\": \"Email Tracking System\",\n                \"tracking_urls\": tracking_urls,\n                \"tracking_domain\": tracking_domain\n            }\n        )\n        \n        return tracking_urls\n    \n    def create_tenant_unsubscribe_system(self, tenant_id: str, config: Dict[str, Any]) -> TenantResource:\n        \"\"\"Create tenant-specific unsubscribe system\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        \n        unsubscribe_data = {\n            \"name\": \"Unsubscribe System\",\n            \"page_title\": config.get(\"page_title\", \"Manage Your Email Preferences\"),\n            \"confirmation_message\": config.get(\"confirmation_message\", \"You have been successfully unsubscribed.\"),\n            \"branding\": tenant_config.brand_customization if tenant_config else {},\n            \"custom_domain\": tenant_config.custom_domain if tenant_config else None,\n            \"unsubscribe_groups\": config.get(\"unsubscribe_groups\", [\"all\"]),\n            \"preference_options\": config.get(\"preference_options\", [])\n        }\n        \n        return self.create_isolated_resource(\n            tenant_id=tenant_id,\n            resource_type=TenantResourceType.UNSUBSCRIBE_PAGE,\n            resource_data=unsubscribe_data\n        )\n    \n    def enforce_sending_limits(self, tenant_id: str, email_count: int) -> Dict[str, Any]:\n        \"\"\"Enforce tenant-specific sending limits\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        if not tenant_config:\n            return {\"allowed\": False, \"reason\": \"Tenant not configured\"}\n        \n        limits = tenant_config.sending_limits\n        \n        # Check daily limit (simplified - in real implementation would check actual usage)\n        daily_limit = limits.get(\"daily\", 1000)\n        if email_count > daily_limit:\n            return {\n                \"allowed\": False,\n                \"reason\": f\"Daily limit exceeded ({email_count} > {daily_limit})\",\n                \"retry_after\": \"24 hours\"\n            }\n        \n        # Check hourly limit\n        hourly_limit = limits.get(\"hourly\", 100)\n        if email_count > hourly_limit:\n            return {\n                \"allowed\": False,\n                \"reason\": f\"Hourly limit exceeded ({email_count} > {hourly_limit})\",\n                \"retry_after\": \"1 hour\"\n            }\n        \n        return {\"allowed\": True, \"remaining\": daily_limit - email_count}\n    \n    def validate_cross_tenant_access(self, requesting_tenant: str, target_tenant: str, resource_id: str) -> bool:\n        \"\"\"Validate and log cross-tenant access attempts\"\"\"\n        \n        # Log access attempt\n        access_log = {\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"requesting_tenant\": requesting_tenant,\n            \"target_tenant\": target_tenant,\n            \"resource_id\": resource_id,\n            \"access_granted\": False,\n            \"reason\": \"Cross-tenant access denied\"\n        }\n        \n        # Check if cross-tenant access is allowed\n        requesting_config = self.tenant_configs.get(requesting_tenant)\n        target_config = self.tenant_configs.get(target_tenant)\n        \n        if not requesting_config or not target_config:\n            access_log[\"reason\"] = \"Invalid tenant configuration\"\n            self.cross_tenant_access_log.append(access_log)\n            return False\n        \n        # Strict isolation - no cross-tenant access\n        if (requesting_config.isolation_level == IsolationLevel.STRICT or \n            target_config.isolation_level == IsolationLevel.STRICT):\n            access_log[\"reason\"] = \"Strict isolation enforced\"\n            self.cross_tenant_access_log.append(access_log)\n            return False\n        \n        # White-label tenants have strict isolation by default\n        if (requesting_config.tier == TenantTier.WHITE_LABEL or \n            target_config.tier == TenantTier.WHITE_LABEL):\n            access_log[\"reason\"] = \"White-label isolation enforced\"\n            self.cross_tenant_access_log.append(access_log)\n            return False\n        \n        self.cross_tenant_access_log.append(access_log)\n        return False  # Default deny\n    \n    def create_tenant_compliance_settings(self, tenant_id: str, compliance_config: Dict[str, Any]) -> TenantComplianceSettings:\n        \"\"\"Create tenant-specific compliance settings\"\"\"\n        \n        compliance = TenantComplianceSettings(\n            tenant_id=tenant_id,\n            gdpr_enabled=compliance_config.get(\"gdpr_enabled\", False),\n            ccpa_enabled=compliance_config.get(\"ccpa_enabled\", False),\n            can_spam_enabled=compliance_config.get(\"can_spam_enabled\", True),\n            double_opt_in_required=compliance_config.get(\"double_opt_in_required\", False),\n            unsubscribe_required=compliance_config.get(\"unsubscribe_required\", True),\n            data_retention_days=compliance_config.get(\"data_retention_days\", 365),\n            consent_tracking=compliance_config.get(\"consent_tracking\", True),\n            preference_center_enabled=compliance_config.get(\"preference_center_enabled\", True)\n        )\n        \n        # Store compliance settings as resource\n        self.create_isolated_resource(\n            tenant_id=tenant_id,\n            resource_type=TenantResourceType.PREFERENCE_CENTER,\n            resource_data={\n                \"name\": \"Compliance Settings\",\n                \"settings\": compliance.dict()\n            }\n        )\n        \n        return compliance\n    \n    def generate_tenant_isolation_report(self, tenant_id: str) -> Dict[str, Any]:\n        \"\"\"Generate isolation and compliance report for tenant\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        if not tenant_config:\n            return {\"error\": \"Tenant not found\"}\n        \n        tenant_resources = self.tenant_resources.get(tenant_id, [])\n        tenant_domains = self.tenant_domains.get(tenant_id, [])\n        \n        # Calculate resource counts\n        resource_counts = {}\n        for resource_type in TenantResourceType:\n            resource_counts[resource_type] = len([\n                r for r in tenant_resources if r.resource_type == resource_type\n            ])\n        \n        # Check cross-tenant access attempts\n        access_violations = [\n            log for log in self.cross_tenant_access_log \n            if log[\"requesting_tenant\"] == tenant_id or log[\"target_tenant\"] == tenant_id\n        ]\n        \n        return {\n            \"tenant_id\": tenant_id,\n            \"tier\": tenant_config.tier,\n            \"isolation_level\": tenant_config.isolation_level,\n            \"custom_domain\": tenant_config.custom_domain,\n            \"dedicated_ip\": tenant_config.dedicated_ip,\n            \"resource_counts\": resource_counts,\n            \"email_domains\": len(tenant_domains),\n            \"sending_limits\": tenant_config.sending_limits,\n            \"compliance_configured\": bool(tenant_config.compliance_settings),\n            \"access_violations\": len(access_violations),\n            \"isolation_score\": self._calculate_isolation_score(tenant_config, resource_counts, access_violations),\n            \"recommendations\": self._generate_isolation_recommendations(tenant_config, resource_counts, access_violations)\n        }\n    \n    def _validate_tenant_access(self, tenant_id: str) -> bool:\n        \"\"\"Validate tenant access permissions\"\"\"\n        return tenant_id in self.tenant_configs\n    \n    def _sanitize_resource_data(self, data: Dict[str, Any], tenant_id: str) -> Dict[str, Any]:\n        \"\"\"Sanitize resource data to prevent tenant leakage\"\"\"\n        \n        sanitized = data.copy()\n        \n        # Add tenant identifier to all resources\n        sanitized[\"tenant_id\"] = tenant_id\n        sanitized[\"isolation_hash\"] = self._generate_tenant_hash(tenant_id)\n        \n        # Remove any cross-tenant references\n        if \"external_tenant_refs\" in sanitized:\n            del sanitized[\"external_tenant_refs\"]\n        \n        return sanitized\n    \n    def _apply_tenant_branding(self, template_data: Dict[str, Any], branding: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Apply tenant-specific branding to templates\"\"\"\n        \n        branded_data = template_data.copy()\n        \n        # Apply branding variables\n        if \"html_content\" in branded_data and branding:\n            html = branded_data[\"html_content\"]\n            \n            # Replace branding placeholders\n            for key, value in branding.items():\n                placeholder = f\"{{{{{key}}}}}\"\n                html = html.replace(placeholder, str(value))\n            \n            branded_data[\"html_content\"] = html\n        \n        return branded_data\n    \n    def _validate_contact_compliance(self, tenant_id: str, contacts: List[Dict[str, Any]]) -> None:\n        \"\"\"Validate contact data for compliance\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        if not tenant_config:\n            return\n        \n        compliance = tenant_config.compliance_settings\n        \n        for contact in contacts:\n            # GDPR compliance check\n            if compliance.get(\"gdpr_enabled\", False):\n                if \"consent_given\" not in contact or not contact[\"consent_given\"]:\n                    raise ValueError(f\"GDPR compliance: Missing consent for contact {contact.get('email')}\")\n            \n            # Double opt-in check\n            if compliance.get(\"double_opt_in_required\", False):\n                if \"opt_in_confirmed\" not in contact or not contact[\"opt_in_confirmed\"]:\n                    raise ValueError(f\"Double opt-in required for contact {contact.get('email')}\")\n    \n    def _generate_tenant_hash(self, tenant_id: str) -> str:\n        \"\"\"Generate unique hash for tenant isolation\"\"\"\n        return hashlib.sha256(f\"tenant_{tenant_id}\".encode()).hexdigest()[:16]\n    \n    def _get_tenant_tracking_domain(self, tenant_id: str) -> str:\n        \"\"\"Get tenant-specific tracking domain\"\"\"\n        \n        tenant_config = self.tenant_configs.get(tenant_id)\n        \n        if tenant_config and tenant_config.custom_domain:\n            return f\"track.{tenant_config.custom_domain}\"\n        \n        # Use tenant hash for subdomain isolation\n        tenant_hash = self._generate_tenant_hash(tenant_id)\n        return f\"{tenant_hash}.tracking.bizosaas.com\"\n    \n    def _generate_dns_configuration(self, domain: TenantEmailDomain) -> Dict[str, str]:\n        \"\"\"Generate DNS configuration for tenant domain\"\"\"\n        \n        return {\n            \"spf_record\": f\"v=spf1 include:mail.bizosaas.com ~all\",\n            \"dkim_record\": f\"bizosaas._domainkey.{domain.domain} IN TXT 'v=DKIM1; k=rsa; p=...'\",\n            \"dmarc_record\": f\"_dmarc.{domain.domain} IN TXT 'v=DMARC1; p=quarantine; rua=mailto:dmarc@{domain.domain}'\",\n            \"mx_record\": f\"{domain.domain} IN MX 10 mail.bizosaas.com\"\n        }\n    \n    def _calculate_isolation_score(self, config: TenantConfiguration, resource_counts: Dict, violations: List) -> float:\n        \"\"\"Calculate tenant isolation score (0-100)\"\"\"\n        \n        score = 0\n        \n        # Base score by isolation level\n        if config.isolation_level == IsolationLevel.STRICT:\n            score += 40\n        elif config.isolation_level == IsolationLevel.MODERATE:\n            score += 25\n        else:\n            score += 10\n        \n        # Custom domain bonus\n        if config.custom_domain:\n            score += 20\n        \n        # Dedicated IP bonus\n        if config.dedicated_ip:\n            score += 15\n        \n        # Resource isolation score\n        total_resources = sum(resource_counts.values())\n        if total_resources > 0:\n            score += min(15, total_resources * 0.5)\n        \n        # Penalty for violations\n        score -= len(violations) * 2\n        \n        # Compliance bonus\n        if config.compliance_settings:\n            score += 10\n        \n        return max(0, min(100, score))\n    \n    def _generate_isolation_recommendations(self, config: TenantConfiguration, resource_counts: Dict, violations: List) -> List[str]:\n        \"\"\"Generate recommendations for improving tenant isolation\"\"\"\n        \n        recommendations = []\n        \n        if not config.custom_domain:\n            recommendations.append(\"Consider setting up a custom domain for better brand isolation\")\n        \n        if config.isolation_level != IsolationLevel.STRICT:\n            recommendations.append(\"Upgrade to strict isolation level for maximum security\")\n        \n        if not config.dedicated_ip:\n            recommendations.append(\"Consider a dedicated IP address for improved deliverability\")\n        \n        if violations:\n            recommendations.append(\"Review and address cross-tenant access violations\")\n        \n        if not config.compliance_settings:\n            recommendations.append(\"Configure compliance settings (GDPR/CCPA) for your region\")\n        \n        return recommendations