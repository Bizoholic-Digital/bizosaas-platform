#!/usr/bin/env python3
"""
Main Product Sourcing Agent
Orchestrates the entire product discovery and analysis workflow
"""

import asyncio
import time
import json
from typing import Dict, List, Any, Optional
from datetime import datetime

from .base_agent import BaseProductSourcingAgent, AgentResponse
from .trend_analysis_agent import TrendAnalysisAgent
from .competitor_monitor_agent import CompetitorMonitorAgent
from .profit_calculation_agent import ProfitCalculationAgent
from .quality_assessment_agent import QualityAssessmentAgent
from .risk_evaluation_agent import RiskEvaluationAgent
from .forecasting_agent import ForecastingAgent

class ProductSourcingAgent(BaseProductSourcingAgent):
    """
    Main orchestrator agent for product sourcing workflow
    Coordinates all specialized agents to provide comprehensive product analysis
    """
    
    def __init__(self, openai_api_key: str = None, brain_service_url: str = None):
        super().__init__("ProductSourcingAgent", openai_api_key)
        self.brain_service_url = brain_service_url or "http://localhost:8001"
        
        # Initialize specialized agents
        self.trend_agent = TrendAnalysisAgent(openai_api_key)
        self.competitor_agent = CompetitorMonitorAgent(openai_api_key, brain_service_url)
        self.profit_agent = ProfitCalculationAgent(openai_api_key)
        self.quality_agent = QualityAssessmentAgent(openai_api_key)
        self.risk_agent = RiskEvaluationAgent(openai_api_key)
        self.forecasting_agent = ForecastingAgent(openai_api_key)
        
    async def process(self, input_data: Dict[str, Any]) -> AgentResponse:\n        \"\"\"Process product sourcing request through complete workflow\"\"\"\n        start_time = time.time()\n        \n        try:\n            self.logger.info(f\"Starting product sourcing workflow for: {input_data}\")\n            \n            # Extract key parameters\n            keywords = input_data.get(\"keywords\", [])\n            category = input_data.get(\"category\")\n            market_region = input_data.get(\"market_region\", \"IN\")\n            \n            if not keywords:\n                return self._create_response(\n                    False, \n                    {}, \n                    0.0, \n                    time.time() - start_time,\n                    [\"Keywords are required for product sourcing\"]\n                )\n            \n            # Stage 1: Trend Detection and Initial Discovery\n            self.logger.info(\"Stage 1: Trend Detection\")\n            trend_results = await self._stage_1_trend_detection(keywords, category)\n            \n            # Stage 2: Product Discovery and Data Collection\n            self.logger.info(\"Stage 2: Product Discovery\")\n            discovery_results = await self._stage_2_product_discovery(keywords, category, market_region)\n            \n            # Stage 3: Competitive Intelligence\n            self.logger.info(\"Stage 3: Competitive Analysis\")\n            competition_results = await self._stage_3_competitive_analysis(keywords, category)\n            \n            # Stage 4: Financial Analysis and Profit Calculation\n            self.logger.info(\"Stage 4: Profit Analysis\")\n            profit_results = await self._stage_4_profit_analysis(discovery_results)\n            \n            # Stage 5: Quality and Risk Assessment\n            self.logger.info(\"Stage 5: Quality & Risk Assessment\")\n            quality_risk_results = await self._stage_5_quality_risk_assessment(discovery_results)\n            \n            # Stage 6: Market Forecasting and Recommendations\n            self.logger.info(\"Stage 6: Forecasting & Recommendations\")\n            forecast_results = await self._stage_6_forecasting_recommendations(\n                trend_results, discovery_results, competition_results, profit_results, quality_risk_results\n            )\n            \n            # Compile final results\n            final_results = {\n                \"workflow_summary\": {\n                    \"total_products_analyzed\": len(discovery_results.get(\"products\", [])),\n                    \"high_potential_products\": len([\n                        p for p in discovery_results.get(\"products\", []) \n                        if p.get(\"overall_score\", 0) >= 70\n                    ]),\n                    \"processing_stages_completed\": 6,\n                    \"analysis_depth\": \"comprehensive\"\n                },\n                \"stage_1_trends\": trend_results,\n                \"stage_2_discovery\": discovery_results,\n                \"stage_3_competition\": competition_results,\n                \"stage_4_profitability\": profit_results,\n                \"stage_5_quality_risk\": quality_risk_results,\n                \"stage_6_forecasting\": forecast_results,\n                \"top_recommendations\": await self._generate_top_recommendations(\n                    discovery_results, profit_results, quality_risk_results\n                ),\n                \"market_insights\": await self._generate_market_insights(\n                    trend_results, competition_results, forecast_results\n                ),\n                \"action_plan\": await self._generate_action_plan(\n                    discovery_results, profit_results, quality_risk_results\n                )\n            }\n            \n            processing_time = time.time() - start_time\n            confidence = self._calculate_overall_confidence(final_results)\n            \n            self.logger.info(f\"Product sourcing workflow completed in {processing_time:.2f}s\")\n            \n            return self._create_response(\n                True, \n                final_results, \n                confidence, \n                processing_time\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Product sourcing workflow failed: {e}\")\n            return self._create_response(\n                False, \n                {}, \n                0.0, \n                time.time() - start_time,\n                [str(e)]\n            )\n    \n    async def _stage_1_trend_detection(self, keywords: List[str], category: str) -> Dict[str, Any]:\n        \"\"\"Stage 1: Detect trends and viral potential\"\"\"\n        try:\n            trend_data = {\n                \"social_media_trends\": {},\n                \"search_trends\": {},\n                \"influencer_activity\": {},\n                \"viral_indicators\": {},\n                \"trend_summary\": {}\n            }\n            \n            # Analyze trends for each keyword\n            for keyword in keywords:\n                trend_input = {\n                    \"query\": keyword,\n                    \"platforms\": [\"tiktok\", \"instagram\", \"youtube\", \"google\"],\n                    \"time_range\": \"30d\",\n                    \"region\": \"IN\"\n                }\n                \n                trend_response = await self.trend_agent.process(trend_input)\n                if trend_response.success:\n                    trend_data[\"social_media_trends\"][keyword] = trend_response.data\n            \n            # Calculate overall trend metrics\n            trend_data[\"trend_summary\"] = self._calculate_trend_summary(trend_data[\"social_media_trends\"])\n            \n            return trend_data\n            \n        except Exception as e:\n            self.logger.error(f\"Stage 1 trend detection failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _stage_2_product_discovery(self, keywords: List[str], category: str, region: str) -> Dict[str, Any]:\n        \"\"\"Stage 2: Discover and collect product data\"\"\"\n        try:\n            discovery_data = {\n                \"products\": [],\n                \"data_sources\": [],\n                \"market_coverage\": {},\n                \"discovery_metrics\": {}\n            }\n            \n            # Search Amazon marketplace\n            amazon_products = await self._search_amazon_products(keywords, category, region)\n            discovery_data[\"products\"].extend(amazon_products)\n            discovery_data[\"data_sources\"].append(\"amazon_sp_api\")\n            \n            # Search Google Shopping (mock implementation)\n            google_products = await self._search_google_shopping(keywords, category)\n            discovery_data[\"products\"].extend(google_products)\n            discovery_data[\"data_sources\"].append(\"google_shopping\")\n            \n            # Enrich product data\n            for product in discovery_data[\"products\"]:\n                await self._enrich_product_data(product)\n            \n            # Calculate discovery metrics\n            discovery_data[\"discovery_metrics\"] = {\n                \"total_products_found\": len(discovery_data[\"products\"]),\n                \"unique_categories\": len(set(p.get(\"category\", \"unknown\") for p in discovery_data[\"products\"])),\n                \"price_range\": self._calculate_price_range(discovery_data[\"products\"]),\n                \"data_completeness\": self._calculate_data_completeness(discovery_data[\"products\"])\n            }\n            \n            return discovery_data\n            \n        except Exception as e:\n            self.logger.error(f\"Stage 2 product discovery failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _stage_3_competitive_analysis(self, keywords: List[str], category: str) -> Dict[str, Any]:\n        \"\"\"Stage 3: Analyze competitive landscape\"\"\"\n        try:\n            competition_input = {\n                \"keywords\": keywords,\n                \"category\": category,\n                \"market_region\": \"IN\",\n                \"competitor_limit\": 20,\n                \"analysis_depth\": \"comprehensive\"\n            }\n            \n            competition_response = await self.competitor_agent.process(competition_input)\n            \n            if competition_response.success:\n                return competition_response.data\n            else:\n                return {\"error\": \"Competitive analysis failed\"}\n                \n        except Exception as e:\n            self.logger.error(f\"Stage 3 competitive analysis failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _stage_4_profit_analysis(self, discovery_results: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Stage 4: Calculate profit potential and ROI\"\"\"\n        try:\n            products = discovery_results.get(\"products\", [])\n            profit_analyses = []\n            \n            for product in products:\n                profit_input = {\n                    \"product_data\": product,\n                    \"market_region\": \"IN\",\n                    \"include_fees\": True,\n                    \"include_shipping\": True,\n                    \"include_taxes\": True\n                }\n                \n                profit_response = await self.profit_agent.process(profit_input)\n                if profit_response.success:\n                    profit_analyses.append({\n                        \"product_id\": product.get(\"id\"),\n                        \"profit_analysis\": profit_response.data\n                    })\n            \n            # Calculate summary metrics\n            profit_summary = self._calculate_profit_summary(profit_analyses)\n            \n            return {\n                \"individual_analyses\": profit_analyses,\n                \"profit_summary\": profit_summary,\n                \"high_margin_products\": [\n                    analysis for analysis in profit_analyses\n                    if analysis[\"profit_analysis\"].get(\"profit_margin_percent\", 0) >= 30\n                ]\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Stage 4 profit analysis failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _stage_5_quality_risk_assessment(self, discovery_results: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Stage 5: Assess product quality and business risks\"\"\"\n        try:\n            products = discovery_results.get(\"products\", [])\n            assessments = []\n            \n            for product in products:\n                # Quality assessment\n                quality_input = {\"product_data\": product}\n                quality_response = await self.quality_agent.process(quality_input)\n                \n                # Risk assessment\n                risk_input = {\"product_data\": product, \"market_region\": \"IN\"}\n                risk_response = await self.risk_agent.process(risk_input)\n                \n                if quality_response.success and risk_response.success:\n                    assessments.append({\n                        \"product_id\": product.get(\"id\"),\n                        \"quality_assessment\": quality_response.data,\n                        \"risk_assessment\": risk_response.data,\n                        \"overall_rating\": self._calculate_overall_rating(\n                            quality_response.data, risk_response.data\n                        )\n                    })\n            \n            # Generate summary insights\n            quality_risk_summary = self._calculate_quality_risk_summary(assessments)\n            \n            return {\n                \"individual_assessments\": assessments,\n                \"summary\": quality_risk_summary,\n                \"recommended_products\": [\n                    assessment for assessment in assessments\n                    if assessment[\"overall_rating\"] >= 7.0\n                ],\n                \"high_risk_products\": [\n                    assessment for assessment in assessments\n                    if assessment[\"risk_assessment\"].get(\"overall_risk_score\", 0) >= 70\n                ]\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Stage 5 quality/risk assessment failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _stage_6_forecasting_recommendations(self, *stage_results) -> Dict[str, Any]:\n        \"\"\"Stage 6: Generate forecasts and final recommendations\"\"\"\n        try:\n            trend_results, discovery_results, competition_results, profit_results, quality_risk_results = stage_results\n            \n            forecasting_input = {\n                \"trend_data\": trend_results,\n                \"product_data\": discovery_results,\n                \"competition_data\": competition_results,\n                \"profit_data\": profit_results,\n                \"quality_risk_data\": quality_risk_results,\n                \"forecast_horizon\": \"12_months\",\n                \"market_region\": \"IN\"\n            }\n            \n            forecast_response = await self.forecasting_agent.process(forecasting_input)\n            \n            if forecast_response.success:\n                return forecast_response.data\n            else:\n                return {\"error\": \"Forecasting failed\"}\n                \n        except Exception as e:\n            self.logger.error(f\"Stage 6 forecasting failed: {e}\")\n            return {\"error\": str(e)}\n    \n    # Helper methods for data processing and API integration\n    \n    async def _search_amazon_products(self, keywords: List[str], category: str, region: str) -> List[Dict]:\n        \"\"\"Search Amazon marketplace via Brain AI service\"\"\"\n        try:\n            products = []\n            for keyword in keywords:\n                url = f\"{self.brain_service_url}/amazon/search\"\n                data = {\n                    \"keywords\": [keyword],\n                    \"category\": category,\n                    \"marketplace_id\": \"A21TJRUUN4KGV\",  # India marketplace\n                    \"limit\": 20\n                }\n                \n                response = await self._make_http_request(url, \"POST\", data=data)\n                if response and \"products\" in response:\n                    products.extend(response[\"products\"])\n            \n            return products\n            \n        except Exception as e:\n            self.logger.error(f\"Amazon product search failed: {e}\")\n            return []\n    \n    async def _search_google_shopping(self, keywords: List[str], category: str) -> List[Dict]:\n        \"\"\"Search Google Shopping (mock implementation)\"\"\"\n        try:\n            # Mock Google Shopping results\n            products = []\n            for i, keyword in enumerate(keywords):\n                for j in range(5):  # 5 products per keyword\n                    products.append({\n                        \"id\": f\"google_{i}_{j}\",\n                        \"title\": f\"{keyword} Product {j}\",\n                        \"price\": round(50 + (i * 10) + (j * 5), 2),\n                        \"currency\": \"INR\",\n                        \"source\": \"google_shopping\",\n                        \"category\": category or \"general\",\n                        \"availability\": \"in_stock\",\n                        \"merchant\": f\"Merchant {j}\"\n                    })\n            \n            return products\n            \n        except Exception as e:\n            self.logger.error(f\"Google Shopping search failed: {e}\")\n            return []\n    \n    async def _enrich_product_data(self, product: Dict[str, Any]) -> None:\n        \"\"\"Enrich product data with additional information\"\"\"\n        try:\n            # Add calculated fields\n            product[\"keywords\"] = self._extract_keywords(product.get(\"title\", \"\"))\n            product[\"sentiment_score\"] = self._calculate_sentiment_score(\n                product.get(\"description\", product.get(\"title\", \"\"))\n            )\n            product[\"data_completeness\"] = self._calculate_product_data_completeness(product)\n            \n            # Add Indian market specific data\n            if product.get(\"price\"):\n                product[\"price_inr\"] = product[\"price\"]  # Assume already in INR\n                product[\"gst_applicable\"] = True\n                product[\"import_duty_estimate\"] = product[\"price\"] * 0.18  # 18% estimate\n            \n        except Exception as e:\n            self.logger.error(f\"Product enrichment failed: {e}\")\n    \n    def _calculate_trend_summary(self, trends_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Calculate overall trend summary\"\"\"\n        try:\n            all_scores = []\n            for keyword_trends in trends_data.values():\n                if \"overall_score\" in keyword_trends:\n                    all_scores.append(keyword_trends[\"overall_score\"])\n            \n            if not all_scores:\n                return {\"overall_trend_score\": 0, \"trend_direction\": \"unknown\"}\n            \n            avg_score = sum(all_scores) / len(all_scores)\n            \n            return {\n                \"overall_trend_score\": avg_score,\n                \"trend_direction\": \"up\" if avg_score >= 60 else \"stable\" if avg_score >= 40 else \"down\",\n                \"trending_keywords\": len([s for s in all_scores if s >= 70]),\n                \"stable_keywords\": len([s for s in all_scores if 40 <= s < 70]),\n                \"declining_keywords\": len([s for s in all_scores if s < 40])\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Trend summary calculation failed: {e}\")\n            return {\"error\": str(e)}\n    \n    def _calculate_price_range(self, products: List[Dict]) -> Dict[str, float]:\n        \"\"\"Calculate price range for products\"\"\"\n        try:\n            prices = [p.get(\"price\", 0) for p in products if p.get(\"price\")]\n            if not prices:\n                return {\"min\": 0, \"max\": 0, \"avg\": 0, \"median\": 0}\n            \n            return {\n                \"min\": min(prices),\n                \"max\": max(prices),\n                \"avg\": sum(prices) / len(prices),\n                \"median\": sorted(prices)[len(prices) // 2]\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Price range calculation failed: {e}\")\n            return {\"min\": 0, \"max\": 0, \"avg\": 0, \"median\": 0}\n    \n    def _calculate_data_completeness(self, products: List[Dict]) -> float:\n        \"\"\"Calculate overall data completeness percentage\"\"\"\n        try:\n            if not products:\n                return 0.0\n            \n            total_score = 0\n            for product in products:\n                total_score += self._calculate_product_data_completeness(product)\n            \n            return total_score / len(products)\n            \n        except Exception as e:\n            self.logger.error(f\"Data completeness calculation failed: {e}\")\n            return 0.0\n    \n    def _calculate_product_data_completeness(self, product: Dict[str, Any]) -> float:\n        \"\"\"Calculate data completeness for single product\"\"\"\n        required_fields = [\"title\", \"price\", \"category\", \"description\", \"images\", \"rating\"]\n        present_fields = sum(1 for field in required_fields if product.get(field))\n        return (present_fields / len(required_fields)) * 100\n    \n    async def _generate_top_recommendations(self, discovery_results, profit_results, quality_risk_results) -> List[Dict]:\n        \"\"\"Generate top product recommendations\"\"\"\n        try:\n            # Combine all data to rank products\n            recommendations = []\n            products = discovery_results.get(\"products\", [])\n            profit_analyses = {pa[\"product_id\"]: pa[\"profit_analysis\"] for pa in profit_results.get(\"individual_analyses\", [])}\n            quality_assessments = {qa[\"product_id\"]: qa for qa in quality_risk_results.get(\"individual_assessments\", [])}\n            \n            for product in products:\n                product_id = product.get(\"id\")\n                profit_data = profit_analyses.get(product_id, {})\n                quality_data = quality_assessments.get(product_id, {})\n                \n                # Calculate composite score\n                composite_score = self._calculate_composite_score(product, profit_data, quality_data)\n                \n                if composite_score >= 70:  # Only include high-potential products\n                    recommendations.append({\n                        \"product\": product,\n                        \"composite_score\": composite_score,\n                        \"profit_margin\": profit_data.get(\"profit_margin_percent\", 0),\n                        \"quality_rating\": quality_data.get(\"overall_rating\", 0),\n                        \"recommendation_reason\": self._generate_recommendation_reason(product, profit_data, quality_data)\n                    })\n            \n            # Sort by composite score\n            recommendations.sort(key=lambda x: x[\"composite_score\"], reverse=True)\n            \n            return recommendations[:10]  # Top 10 recommendations\n            \n        except Exception as e:\n            self.logger.error(f\"Top recommendations generation failed: {e}\")\n            return []\n    \n    def _calculate_composite_score(self, product: Dict, profit_data: Dict, quality_data: Dict) -> float:\n        \"\"\"Calculate composite score for product ranking\"\"\"\n        try:\n            # Weight different factors\n            weights = {\n                \"profit\": 0.4,\n                \"quality\": 0.3,\n                \"trend\": 0.2,\n                \"risk\": 0.1\n            }\n            \n            profit_score = profit_data.get(\"profit_margin_percent\", 0)\n            quality_score = quality_data.get(\"quality_assessment\", {}).get(\"overall_quality_score\", 0)\n            risk_score = 100 - quality_data.get(\"risk_assessment\", {}).get(\"overall_risk_score\", 100)\n            trend_score = product.get(\"trend_score\", 50)  # Default neutral\n            \n            composite = (\n                profit_score * weights[\"profit\"] +\n                quality_score * weights[\"quality\"] +\n                trend_score * weights[\"trend\"] +\n                risk_score * weights[\"risk\"]\n            )\n            \n            return min(100.0, max(0.0, composite))\n            \n        except Exception as e:\n            self.logger.error(f\"Composite score calculation failed: {e}\")\n            return 0.0\n    \n    def _generate_recommendation_reason(self, product: Dict, profit_data: Dict, quality_data: Dict) -> str:\n        \"\"\"Generate human-readable recommendation reason\"\"\"\n        try:\n            reasons = []\n            \n            profit_margin = profit_data.get(\"profit_margin_percent\", 0)\n            if profit_margin >= 40:\n                reasons.append(f\"High profit margin ({profit_margin:.1f}%)\")\n            elif profit_margin >= 25:\n                reasons.append(f\"Good profit margin ({profit_margin:.1f}%)\")\n            \n            quality_score = quality_data.get(\"quality_assessment\", {}).get(\"overall_quality_score\", 0)\n            if quality_score >= 80:\n                reasons.append(\"Excellent quality rating\")\n            elif quality_score >= 65:\n                reasons.append(\"Good quality rating\")\n            \n            risk_score = quality_data.get(\"risk_assessment\", {}).get(\"overall_risk_score\", 100)\n            if risk_score <= 30:\n                reasons.append(\"Low business risk\")\n            elif risk_score <= 50:\n                reasons.append(\"Moderate risk profile\")\n            \n            return \", \".join(reasons) if reasons else \"Meets basic criteria\"\n            \n        except Exception as e:\n            self.logger.error(f\"Recommendation reason generation failed: {e}\")\n            return \"Analysis completed\"\n    \n    async def _generate_market_insights(self, trend_results, competition_results, forecast_results) -> Dict[str, Any]:\n        \"\"\"Generate market insights summary\"\"\"\n        try:\n            insights = {\n                \"market_opportunity\": \"medium\",\n                \"competitive_intensity\": \"medium\",\n                \"growth_potential\": \"medium\",\n                \"key_insights\": [],\n                \"market_trends\": [],\n                \"recommendations\": []\n            }\n            \n            # Analyze trend data\n            trend_score = trend_results.get(\"trend_summary\", {}).get(\"overall_trend_score\", 50)\n            if trend_score >= 70:\n                insights[\"market_opportunity\"] = \"high\"\n                insights[\"key_insights\"].append(\"Strong upward trends detected across multiple platforms\")\n            elif trend_score <= 30:\n                insights[\"market_opportunity\"] = \"low\"\n                insights[\"key_insights\"].append(\"Declining trend patterns observed\")\n            \n            # Analyze competition\n            competitor_count = competition_results.get(\"competitor_analysis\", {}).get(\"competitor_count\", 0)\n            if competitor_count <= 20:\n                insights[\"competitive_intensity\"] = \"low\"\n                insights[\"recommendations\"].append(\"Low competition - good entry opportunity\")\n            elif competitor_count >= 100:\n                insights[\"competitive_intensity\"] = \"high\"\n                insights[\"recommendations\"].append(\"High competition - focus on differentiation\")\n            \n            # Add forecasting insights\n            growth_forecast = forecast_results.get(\"growth_forecast\", {}).get(\"next_quarter\", 0)\n            if growth_forecast >= 20:\n                insights[\"growth_potential\"] = \"high\"\n                insights[\"market_trends\"].append(f\"Expected {growth_forecast:.1f}% growth next quarter\")\n            \n            return insights\n            \n        except Exception as e:\n            self.logger.error(f\"Market insights generation failed: {e}\")\n            return {\"error\": str(e)}\n    \n    async def _generate_action_plan(self, discovery_results, profit_results, quality_risk_results) -> Dict[str, Any]:\n        \"\"\"Generate actionable plan based on analysis\"\"\"\n        try:\n            action_plan = {\n                \"immediate_actions\": [],\n                \"short_term_goals\": [],\n                \"long_term_strategy\": [],\n                \"priority_products\": [],\n                \"resource_requirements\": {},\n                \"timeline\": {}\n            }\n            \n            # Identify high-priority products\n            high_potential_products = [\n                p for p in discovery_results.get(\"products\", [])\n                if self._calculate_composite_score(\n                    p, \n                    profit_results.get(\"individual_analyses\", [{}])[0].get(\"profit_analysis\", {}),\n                    quality_risk_results.get(\"individual_assessments\", [{}])[0]\n                ) >= 70\n            ]\n            \n            if high_potential_products:\n                action_plan[\"immediate_actions\"].extend([\n                    f\"Conduct deeper analysis on {len(high_potential_products)} high-potential products\",\n                    \"Contact suppliers for pricing and minimum order quantities\",\n                    \"Set up product listing optimization strategy\"\n                ])\n                \n                action_plan[\"short_term_goals\"].extend([\n                    \"Launch pilot campaign with top 3 products\",\n                    \"Establish supplier relationships\",\n                    \"Set up inventory management system\"\n                ])\n                \n                action_plan[\"priority_products\"] = [\n                    {\n                        \"product_title\": p.get(\"title\", \"\"),\n                        \"estimated_investment\": p.get(\"price\", 0) * 10,  # Assume 10 unit minimum\n                        \"expected_roi\": \"25-40%\"\n                    }\n                    for p in high_potential_products[:5]\n                ]\n            \n            # Resource requirements\n            total_investment = sum(p.get(\"price\", 0) * 10 for p in high_potential_products[:5])\n            action_plan[\"resource_requirements\"] = {\n                \"initial_investment\": total_investment,\n                \"monthly_marketing_budget\": total_investment * 0.1,\n                \"team_requirements\": [\"Product sourcing specialist\", \"Marketing coordinator\"]\n            }\n            \n            # Timeline\n            action_plan[\"timeline\"] = {\n                \"week_1\": \"Supplier research and contact\",\n                \"week_2_3\": \"Sample ordering and quality testing\",\n                \"week_4\": \"Listing creation and launch preparation\",\n                \"month_2\": \"Launch and initial marketing campaigns\",\n                \"month_3\": \"Performance analysis and optimization\"\n            }\n            \n            return action_plan\n            \n        except Exception as e:\n            self.logger.error(f\"Action plan generation failed: {e}\")\n            return {\"error\": str(e)}\n    \n    def _calculate_overall_confidence(self, results: Dict[str, Any]) -> float:\n        \"\"\"Calculate overall confidence in the analysis\"\"\"\n        try:\n            confidence_factors = []\n            \n            # Data completeness factor\n            data_completeness = results.get(\"stage_2_discovery\", {}).get(\"discovery_metrics\", {}).get(\"data_completeness\", 0)\n            confidence_factors.append(data_completeness / 100)\n            \n            # Number of products analyzed\n            product_count = results.get(\"workflow_summary\", {}).get(\"total_products_analyzed\", 0)\n            product_factor = min(1.0, product_count / 50)  # Normalize to 50 products\n            confidence_factors.append(product_factor)\n            \n            # Analysis depth\n            stages_completed = results.get(\"workflow_summary\", {}).get(\"processing_stages_completed\", 0)\n            stage_factor = stages_completed / 6  # 6 total stages\n            confidence_factors.append(stage_factor)\n            \n            # Calculate weighted average\n            if confidence_factors:\n                return sum(confidence_factors) / len(confidence_factors)\n            else:\n                return 0.5\n                \n        except Exception as e:\n            self.logger.error(f\"Confidence calculation failed: {e}\")\n            return 0.5\n    \n    def _calculate_profit_summary(self, profit_analyses: List[Dict]) -> Dict[str, Any]:\n        \"\"\"Calculate profit analysis summary\"\"\"\n        try:\n            if not profit_analyses:\n                return {}\n            \n            margins = [pa[\"profit_analysis\"].get(\"profit_margin_percent\", 0) for pa in profit_analyses]\n            \n            return {\n                \"average_margin\": sum(margins) / len(margins),\n                \"highest_margin\": max(margins),\n                \"lowest_margin\": min(margins),\n                \"profitable_products\": len([m for m in margins if m >= 20]),\n                \"high_margin_products\": len([m for m in margins if m >= 40])\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Profit summary calculation failed: {e}\")\n            return {}\n    \n    def _calculate_overall_rating(self, quality_data: Dict, risk_data: Dict) -> float:\n        \"\"\"Calculate overall product rating\"\"\"\n        try:\n            quality_score = quality_data.get(\"overall_quality_score\", 0)\n            risk_score = risk_data.get(\"overall_risk_score\", 100)\n            \n            # Convert to 1-10 scale\n            quality_rating = quality_score / 10\n            risk_rating = (100 - risk_score) / 10\n            \n            # Weighted average (quality 70%, risk 30%)\n            overall_rating = (quality_rating * 0.7) + (risk_rating * 0.3)\n            \n            return min(10.0, max(1.0, overall_rating))\n            \n        except Exception as e:\n            self.logger.error(f\"Overall rating calculation failed: {e}\")\n            return 5.0\n    \n    def _calculate_quality_risk_summary(self, assessments: List[Dict]) -> Dict[str, Any]:\n        \"\"\"Calculate quality and risk assessment summary\"\"\"\n        try:\n            if not assessments:\n                return {}\n            \n            quality_scores = [a[\"quality_assessment\"].get(\"overall_quality_score\", 0) for a in assessments]\n            risk_scores = [a[\"risk_assessment\"].get(\"overall_risk_score\", 100) for a in assessments]\n            overall_ratings = [a[\"overall_rating\"] for a in assessments]\n            \n            return {\n                \"average_quality\": sum(quality_scores) / len(quality_scores),\n                \"average_risk\": sum(risk_scores) / len(risk_scores),\n                \"average_overall_rating\": sum(overall_ratings) / len(overall_ratings),\n                \"high_quality_products\": len([q for q in quality_scores if q >= 80]),\n                \"low_risk_products\": len([r for r in risk_scores if r <= 30]),\n                \"recommended_products\": len([r for r in overall_ratings if r >= 7.0])\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Quality risk summary calculation failed: {e}\")\n            return {}