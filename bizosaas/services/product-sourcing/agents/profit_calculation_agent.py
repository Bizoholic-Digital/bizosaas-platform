#!/usr/bin/env python3
"""
Profit Calculation Agent for Product Sourcing
Calculates profit margins, ROI, and financial viability
"""

import time
import numpy as np
from typing import Dict, List, Any
from datetime import datetime

from .base_agent import BaseProductSourcingAgent, AgentResponse

class ProfitCalculationAgent(BaseProductSourcingAgent):
    """
    Specialized agent for financial analysis and profit calculation
    Handles pricing, costs, margins, ROI, and financial projections
    """
    
    def __init__(self, openai_api_key: str = None):
        super().__init__("ProfitCalculationAgent", openai_api_key)
        
        # Indian market specific rates and fees
        self.gst_rate = 0.18  # 18% GST
        self.amazon_referral_fees = {
            "electronics": 0.08,
            "home": 0.10,
            "fashion": 0.15,
            "sports": 0.12,
            "books": 0.05,
            "default": 0.10
        }
        self.amazon_fba_fees = {
            "small": 45,  # ₹45 for small items
            "medium": 65,  # ₹65 for medium items
            "large": 85,   # ₹85 for large items
        }
        
    async def process(self, input_data: Dict[str, Any]) -> AgentResponse:
        """Calculate comprehensive profit analysis for product"""
        start_time = time.time()
        
        try:
            product_data = input_data.get("product_data", {})
            market_region = input_data.get("market_region", "IN")
            include_fees = input_data.get("include_fees", True)
            include_shipping = input_data.get("include_shipping", True)
            include_taxes = input_data.get("include_taxes", True)
            
            if not product_data:
                return self._create_response(
                    False, {}, 0.0, time.time() - start_time,
                    ["Product data is required for profit calculation"]
                )
            
            self.logger.info(f"Calculating profit for product: {product_data.get('title', 'Unknown')}")
            
            # Extract pricing information\n            selling_price = product_data.get(\"price\", 0)\n            if not selling_price:\n                selling_price = product_data.get(\"current_price\", 0)\n            \n            if selling_price <= 0:\n                return self._create_response(\n                    False, {}, 0.0, time.time() - start_time,\n                    [\"Valid selling price is required for profit calculation\"]\n                )\n            \n            # Stage 1: Cost Analysis\n            cost_analysis = await self._analyze_costs(product_data, market_region)\n            \n            # Stage 2: Revenue Calculation\n            revenue_analysis = await self._calculate_revenue(product_data, selling_price)\n            \n            # Stage 3: Fee and Tax Calculation\n            fees_taxes = await self._calculate_fees_and_taxes(\n                product_data, selling_price, include_fees, include_taxes\n            )\n            \n            # Stage 4: Shipping Cost Analysis\n            shipping_costs = await self._analyze_shipping_costs(\n                product_data, market_region, include_shipping\n            )\n            \n            # Stage 5: Profit Margin Calculation\n            profit_analysis = await self._calculate_profit_margins(\n                selling_price, cost_analysis, fees_taxes, shipping_costs\n            )\n            \n            # Stage 6: ROI and Financial Projections\n            roi_projections = await self._calculate_roi_projections(\n                profit_analysis, cost_analysis, product_data\n            )\n            \n            # Stage 7: Break-even Analysis\n            breakeven_analysis = await self._calculate_breakeven_analysis(\n                profit_analysis, cost_analysis, fees_taxes\n            )\n            \n            # Stage 8: Risk-adjusted Returns\n            risk_adjusted_returns = await self._calculate_risk_adjusted_returns(\n                profit_analysis, product_data\n            )\n            \n            # Compile comprehensive financial analysis\n            financial_data = {\n                \"analysis_summary\": {\n                    \"product_title\": product_data.get(\"title\", \"Unknown Product\"),\n                    \"selling_price\": selling_price,\n                    \"currency\": \"INR\",\n                    \"market_region\": market_region,\n                    \"analysis_date\": datetime.now().isoformat()\n                },\n                \"cost_breakdown\": cost_analysis,\n                \"revenue_analysis\": revenue_analysis,\n                \"fees_and_taxes\": fees_taxes,\n                \"shipping_costs\": shipping_costs,\n                \"profit_analysis\": profit_analysis,\n                \"roi_projections\": roi_projections,\n                \"breakeven_analysis\": breakeven_analysis,\n                \"risk_adjusted_returns\": risk_adjusted_returns,\n                \"financial_recommendations\": await self._generate_financial_recommendations(\n                    profit_analysis, roi_projections, breakeven_analysis\n                ),\n                \"scenario_analysis\": await self._perform_scenario_analysis(\n                    selling_price, cost_analysis, fees_taxes, shipping_costs\n                ),\n                \"competitive_pricing\": await self._analyze_competitive_pricing(\n                    product_data, selling_price, profit_analysis\n                )\n            }\n            \n            processing_time = time.time() - start_time\n            confidence = self._calculate_financial_confidence(financial_data)\n            \n            self.logger.info(f\"Profit calculation completed in {processing_time:.2f}s\")\n            \n            return self._create_response(\n                True, financial_data, confidence, processing_time\n            )\n            \n        except Exception as e:\n            self.logger.error(f\"Profit calculation failed: {e}\")\n            return self._create_response(\n                False, {}, 0.0, time.time() - start_time, [str(e)]\n            )\n    \n    async def _analyze_costs(self, product_data: Dict, market_region: str) -> Dict[str, Any]:\n        \"\"\"Analyze all cost components\"\"\"\n        try:\n            costs = {\n                \"product_cost\": 0,\n                \"sourcing_cost\": 0,\n                \"packaging_cost\": 0,\n                \"storage_cost\": 0,\n                \"handling_cost\": 0,\n                \"total_cogs\": 0,\n                \"cost_breakdown_percentage\": {}\n            }\n            \n            selling_price = product_data.get(\"price\", product_data.get(\"current_price\", 0))\n            \n            # Product cost estimation\n            if \"cost\" in product_data:\n                costs[\"product_cost\"] = product_data[\"cost\"]\n            elif \"estimated_cost\" in product_data:\n                costs[\"product_cost\"] = product_data[\"estimated_cost\"]\n            else:\n                # Estimate based on selling price and category\n                category = product_data.get(\"category\", \"general\")\n                if category.lower() in [\"electronics\", \"gadgets\"]:\n                    costs[\"product_cost\"] = selling_price * 0.65  # 65% of selling price\n                elif category.lower() in [\"fashion\", \"clothing\"]:\n                    costs[\"product_cost\"] = selling_price * 0.55  # 55% of selling price\n                elif category.lower() in [\"home\", \"kitchen\"]:\n                    costs[\"product_cost\"] = selling_price * 0.60  # 60% of selling price\n                else:\n                    costs[\"product_cost\"] = selling_price * 0.60  # Default 60%\n            \n            # Sourcing and procurement costs\n            costs[\"sourcing_cost\"] = costs[\"product_cost\"] * 0.05  # 5% of product cost\n            \n            # Packaging costs\n            weight = product_data.get(\"weight\", 1.0)  # Default 1kg\n            if weight <= 0.5:\n                costs[\"packaging_cost\"] = 15  # ₹15 for light items\n            elif weight <= 2.0:\n                costs[\"packaging_cost\"] = 25  # ₹25 for medium items\n            else:\n                costs[\"packaging_cost\"] = 40  # ₹40 for heavy items\n            \n            # Storage costs (monthly, allocated per unit)\n            storage_rate_per_kg = 10  # ₹10 per kg per month\n            monthly_turnover = 30  # Assume 30 units per month\n            costs[\"storage_cost\"] = (weight * storage_rate_per_kg) / monthly_turnover\n            \n            # Handling costs\n            costs[\"handling_cost\"] = 10  # ₹10 per unit handling\n            \n            # Total COGS\n            costs[\"total_cogs\"] = (\n                costs[\"product_cost\"] + \n                costs[\"sourcing_cost\"] + \n                costs[\"packaging_cost\"] + \n                costs[\"storage_cost\"] + \n                costs[\"handling_cost\"]\n            )\n            \n            # Cost breakdown percentage\n            if costs[\"total_cogs\"] > 0:\n                costs[\"cost_breakdown_percentage\"] = {\n                    \"product_cost\": (costs[\"product_cost\"] / costs[\"total_cogs\"]) * 100,\n                    \"sourcing_cost\": (costs[\"sourcing_cost\"] / costs[\"total_cogs\"]) * 100,\n                    \"packaging_cost\": (costs[\"packaging_cost\"] / costs[\"total_cogs\"]) * 100,\n                    \"storage_cost\": (costs[\"storage_cost\"] / costs[\"total_cogs\"]) * 100,\n                    \"handling_cost\": (costs[\"handling_cost\"] / costs[\"total_cogs\"]) * 100\n                }\n            \n            return costs\n            \n        except Exception as e:\n            self.logger.error(f\"Cost analysis failed: {e}\")\n            return {\"total_cogs\": 0}\n    \n    async def _calculate_revenue(self, product_data: Dict, selling_price: float) -> Dict[str, Any]:\n        \"\"\"Calculate revenue projections\"\"\"\n        try:\n            revenue = {\n                \"unit_price\": selling_price,\n                \"projected_monthly_units\": 0,\n                \"projected_monthly_revenue\": 0,\n                \"revenue_scenarios\": {},\n                \"seasonal_adjustments\": {}\n            }\n            \n            # Estimate monthly sales volume based on category and price point\n            category = product_data.get(\"category\", \"general\")\n            \n            if selling_price <= 100:\n                base_units = np.random.randint(50, 200)\n            elif selling_price <= 500:\n                base_units = np.random.randint(20, 80)\n            elif selling_price <= 1000:\n                base_units = np.random.randint(10, 40)\n            else:\n                base_units = np.random.randint(5, 20)\n            \n            # Category adjustments\n            category_multipliers = {\n                \"electronics\": 1.2,\n                \"fashion\": 1.5,\n                \"home\": 1.0,\n                \"sports\": 0.8,\n                \"books\": 0.7\n            }\n            \n            multiplier = category_multipliers.get(category.lower(), 1.0)\n            revenue[\"projected_monthly_units\"] = int(base_units * multiplier)\n            revenue[\"projected_monthly_revenue\"] = revenue[\"projected_monthly_units\"] * selling_price\n            \n            # Revenue scenarios\n            revenue[\"revenue_scenarios\"] = {\n                \"conservative\": {\n                    \"units\": int(revenue[\"projected_monthly_units\"] * 0.7),\n                    \"revenue\": int(revenue[\"projected_monthly_units\"] * 0.7) * selling_price\n                },\n                \"realistic\": {\n                    \"units\": revenue[\"projected_monthly_units\"],\n                    \"revenue\": revenue[\"projected_monthly_revenue\"]\n                },\n                \"optimistic\": {\n                    \"units\": int(revenue[\"projected_monthly_units\"] * 1.5),\n                    \"revenue\": int(revenue[\"projected_monthly_units\"] * 1.5) * selling_price\n                }\n            }\n            \n            # Seasonal adjustments (Indian market)\n            revenue[\"seasonal_adjustments\"] = {\n                \"diwali_boost\": 2.0,  # 100% increase during Diwali\n                \"new_year_boost\": 1.5,  # 50% increase during New Year\n                \"summer_decline\": 0.8,  # 20% decline in summer\n                \"monsoon_impact\": 0.9   # 10% decline during monsoon\n            }\n            \n            return revenue\n            \n        except Exception as e:\n            self.logger.error(f\"Revenue calculation failed: {e}\")\n            return {\"projected_monthly_revenue\": 0}\n    \n    async def _calculate_fees_and_taxes(self, product_data: Dict, selling_price: float, include_fees: bool, include_taxes: bool) -> Dict[str, Any]:\n        \"\"\"Calculate marketplace fees and taxes\"\"\"\n        try:\n            fees_taxes = {\n                \"marketplace_fees\": {},\n                \"payment_processing_fees\": 0,\n                \"gst_amount\": 0,\n                \"total_fees_taxes\": 0,\n                \"net_price_after_deductions\": selling_price\n            }\n            \n            if include_fees:\n                # Amazon marketplace fees\n                category = product_data.get(\"category\", \"default\")\n                referral_rate = self.amazon_referral_fees.get(category.lower(), self.amazon_referral_fees[\"default\"])\n                amazon_referral_fee = selling_price * referral_rate\n                \n                # FBA fees based on size\n                weight = product_data.get(\"weight\", 1.0)\n                if weight <= 0.5:\n                    fba_fee = self.amazon_fba_fees[\"small\"]\n                elif weight <= 2.0:\n                    fba_fee = self.amazon_fba_fees[\"medium\"]\n                else:\n                    fba_fee = self.amazon_fba_fees[\"large\"]\n                \n                fees_taxes[\"marketplace_fees\"] = {\n                    \"amazon_referral_fee\": amazon_referral_fee,\n                    \"amazon_fba_fee\": fba_fee,\n                    \"closing_fee\": 20,  # ₹20 closing fee\n                    \"total_marketplace_fees\": amazon_referral_fee + fba_fee + 20\n                }\n                \n                # Payment processing fees (2-3%)\n                fees_taxes[\"payment_processing_fees\"] = selling_price * 0.025\n            \n            if include_taxes:\n                # GST calculation\n                if include_fees:\n                    taxable_amount = selling_price - fees_taxes[\"marketplace_fees\"][\"total_marketplace_fees\"]\n                else:\n                    taxable_amount = selling_price\n                \n                fees_taxes[\"gst_amount\"] = taxable_amount * self.gst_rate\n            \n            # Total deductions\n            total_deductions = (\n                fees_taxes[\"marketplace_fees\"].get(\"total_marketplace_fees\", 0) +\n                fees_taxes[\"payment_processing_fees\"] +\n                fees_taxes[\"gst_amount\"]\n            )\n            \n            fees_taxes[\"total_fees_taxes\"] = total_deductions\n            fees_taxes[\"net_price_after_deductions\"] = selling_price - total_deductions\n            \n            return fees_taxes\n            \n        except Exception as e:\n            self.logger.error(f\"Fees and taxes calculation failed: {e}\")\n            return {\"total_fees_taxes\": 0, \"net_price_after_deductions\": selling_price}\n    \n    async def _analyze_shipping_costs(self, product_data: Dict, market_region: str, include_shipping: bool) -> Dict[str, Any]:\n        \"\"\"Analyze shipping and logistics costs\"\"\"\n        try:\n            shipping = {\n                \"domestic_shipping\": 0,\n                \"international_shipping\": 0,\n                \"return_shipping\": 0,\n                \"total_shipping_costs\": 0,\n                \"shipping_zones\": {}\n            }\n            \n            if not include_shipping:\n                return shipping\n            \n            weight = product_data.get(\"weight\", 1.0)\n            \n            # Domestic shipping costs (India)\n            if weight <= 0.5:\n                shipping[\"domestic_shipping\"] = 40  # ₹40 for <0.5kg\n            elif weight <= 1.0:\n                shipping[\"domestic_shipping\"] = 60  # ₹60 for 0.5-1kg\n            elif weight <= 2.0:\n                shipping[\"domestic_shipping\"] = 80  # ₹80 for 1-2kg\n            else:\n                shipping[\"domestic_shipping\"] = 120  # ₹120 for >2kg\n            \n            # International shipping (if applicable)\n            if market_region != \"IN\":\n                shipping[\"international_shipping\"] = weight * 200  # ₹200 per kg\n            \n            # Return shipping (estimate 5% return rate)\n            return_rate = 0.05\n            shipping[\"return_shipping\"] = shipping[\"domestic_shipping\"] * return_rate\n            \n            # Total shipping costs\n            shipping[\"total_shipping_costs\"] = (\n                shipping[\"domestic_shipping\"] +\n                shipping[\"international_shipping\"] +\n                shipping[\"return_shipping\"]\n            )\n            \n            # Shipping zones analysis\n            shipping[\"shipping_zones\"] = {\n                \"local\": {\"cost\": shipping[\"domestic_shipping\"] * 0.7, \"delivery_time\": \"1-2 days\"},\n                \"regional\": {\"cost\": shipping[\"domestic_shipping\"], \"delivery_time\": \"2-3 days\"},\n                \"national\": {\"cost\": shipping[\"domestic_shipping\"] * 1.3, \"delivery_time\": \"3-5 days\"},\n                \"remote\": {\"cost\": shipping[\"domestic_shipping\"] * 1.8, \"delivery_time\": \"5-7 days\"}\n            }\n            \n            return shipping\n            \n        except Exception as e:\n            self.logger.error(f\"Shipping cost analysis failed: {e}\")\n            return {\"total_shipping_costs\": 0}\n    \n    async def _calculate_profit_margins(self, selling_price: float, costs: Dict, fees_taxes: Dict, shipping: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate comprehensive profit margins\"\"\"\n        try:\n            profit = {\n                \"gross_profit\": 0,\n                \"net_profit\": 0,\n                \"gross_margin_percent\": 0,\n                \"net_margin_percent\": 0,\n                \"profit_per_unit\": 0,\n                \"contribution_margin\": 0,\n                \"margin_analysis\": {}\n            }\n            \n            total_cogs = costs.get(\"total_cogs\", 0)\n            total_fees_taxes = fees_taxes.get(\"total_fees_taxes\", 0)\n            total_shipping = shipping.get(\"total_shipping_costs\", 0)\n            \n            # Gross profit (Revenue - COGS)\n            profit[\"gross_profit\"] = selling_price - total_cogs\n            \n            # Net profit (Gross profit - Fees - Taxes - Shipping)\n            profit[\"net_profit\"] = profit[\"gross_profit\"] - total_fees_taxes - total_shipping\n            \n            # Profit margins\n            if selling_price > 0:\n                profit[\"gross_margin_percent\"] = (profit[\"gross_profit\"] / selling_price) * 100\n                profit[\"net_margin_percent\"] = (profit[\"net_profit\"] / selling_price) * 100\n            \n            profit[\"profit_per_unit\"] = profit[\"net_profit\"]\n            \n            # Contribution margin (covers fixed costs)\n            variable_costs = total_cogs + total_shipping\n            profit[\"contribution_margin\"] = selling_price - variable_costs\n            profit[\"contribution_margin_percent\"] = (profit[\"contribution_margin\"] / selling_price) * 100 if selling_price > 0 else 0\n            \n            # Margin analysis\n            profit[\"margin_analysis\"] = {\n                \"excellent\": profit[\"net_margin_percent\"] >= 40,\n                \"good\": 25 <= profit[\"net_margin_percent\"] < 40,\n                \"acceptable\": 15 <= profit[\"net_margin_percent\"] < 25,\n                \"poor\": 5 <= profit[\"net_margin_percent\"] < 15,\n                \"unprofitable\": profit[\"net_margin_percent\"] < 5,\n                \"margin_category\": self._categorize_margin(profit[\"net_margin_percent\"])\n            }\n            \n            return profit\n            \n        except Exception as e:\n            self.logger.error(f\"Profit margin calculation failed: {e}\")\n            return {\"net_profit\": 0, \"net_margin_percent\": 0}\n    \n    async def _calculate_roi_projections(self, profit_analysis: Dict, cost_analysis: Dict, product_data: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate ROI and investment projections\"\"\"\n        try:\n            roi = {\n                \"monthly_roi\": 0,\n                \"annual_roi\": 0,\n                \"payback_period_months\": 0,\n                \"investment_required\": 0,\n                \"projected_returns\": {},\n                \"roi_scenarios\": {}\n            }\n            \n            # Calculate initial investment\n            initial_inventory = 50  # Start with 50 units\n            unit_cost = cost_analysis.get(\"total_cogs\", 0)\n            roi[\"investment_required\"] = initial_inventory * unit_cost\n            \n            # Monthly profit per unit\n            monthly_profit_per_unit = profit_analysis.get(\"net_profit\", 0)\n            \n            # Estimate monthly sales volume\n            selling_price = product_data.get(\"price\", product_data.get(\"current_price\", 0))\n            estimated_monthly_sales = self._estimate_monthly_sales(selling_price, product_data)\n            \n            # Monthly profit\n            monthly_total_profit = monthly_profit_per_unit * estimated_monthly_sales\n            \n            # ROI calculations\n            if roi[\"investment_required\"] > 0:\n                roi[\"monthly_roi\"] = (monthly_total_profit / roi[\"investment_required\"]) * 100\n                roi[\"annual_roi\"] = roi[\"monthly_roi\"] * 12\n            \n            # Payback period\n            if monthly_total_profit > 0:\n                roi[\"payback_period_months\"] = roi[\"investment_required\"] / monthly_total_profit\n            else:\n                roi[\"payback_period_months\"] = float('inf')\n            \n            # Projected returns\n            roi[\"projected_returns\"] = {\n                \"month_1\": monthly_total_profit,\n                \"month_3\": monthly_total_profit * 3,\n                \"month_6\": monthly_total_profit * 6,\n                \"month_12\": monthly_total_profit * 12\n            }\n            \n            # ROI scenarios\n            roi[\"roi_scenarios\"] = {\n                \"conservative\": {\n                    \"monthly_sales\": int(estimated_monthly_sales * 0.7),\n                    \"monthly_profit\": monthly_profit_per_unit * int(estimated_monthly_sales * 0.7),\n                    \"annual_roi\": (monthly_profit_per_unit * int(estimated_monthly_sales * 0.7) * 12 / roi[\"investment_required\"]) * 100 if roi[\"investment_required\"] > 0 else 0\n                },\n                \"realistic\": {\n                    \"monthly_sales\": estimated_monthly_sales,\n                    \"monthly_profit\": monthly_total_profit,\n                    \"annual_roi\": roi[\"annual_roi\"]\n                },\n                \"optimistic\": {\n                    \"monthly_sales\": int(estimated_monthly_sales * 1.5),\n                    \"monthly_profit\": monthly_profit_per_unit * int(estimated_monthly_sales * 1.5),\n                    \"annual_roi\": (monthly_profit_per_unit * int(estimated_monthly_sales * 1.5) * 12 / roi[\"investment_required\"]) * 100 if roi[\"investment_required\"] > 0 else 0\n                }\n            }\n            \n            return roi\n            \n        except Exception as e:\n            self.logger.error(f\"ROI calculation failed: {e}\")\n            return {\"annual_roi\": 0, \"payback_period_months\": float('inf')}\n    \n    async def _calculate_breakeven_analysis(self, profit_analysis: Dict, cost_analysis: Dict, fees_taxes: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate break-even analysis\"\"\"\n        try:\n            breakeven = {\n                \"breakeven_units\": 0,\n                \"breakeven_revenue\": 0,\n                \"fixed_costs_monthly\": 0,\n                \"variable_cost_per_unit\": 0,\n                \"contribution_margin_per_unit\": 0,\n                \"breakeven_timeline\": {}\n            }\n            \n            # Estimate fixed costs (monthly)\n            breakeven[\"fixed_costs_monthly\"] = 25000  # ₹25,000 monthly fixed costs (storage, marketing, etc.)\n            \n            # Variable costs per unit\n            breakeven[\"variable_cost_per_unit\"] = cost_analysis.get(\"total_cogs\", 0)\n            \n            # Contribution margin per unit\n            breakeven[\"contribution_margin_per_unit\"] = profit_analysis.get(\"contribution_margin\", 0)\n            \n            # Break-even units calculation\n            if breakeven[\"contribution_margin_per_unit\"] > 0:\n                breakeven[\"breakeven_units\"] = breakeven[\"fixed_costs_monthly\"] / breakeven[\"contribution_margin_per_unit\"]\n            else:\n                breakeven[\"breakeven_units\"] = float('inf')\n            \n            # Break-even revenue\n            selling_price = profit_analysis.get(\"profit_per_unit\", 0) + breakeven[\"variable_cost_per_unit\"]\n            breakeven[\"breakeven_revenue\"] = breakeven[\"breakeven_units\"] * selling_price\n            \n            # Break-even timeline scenarios\n            daily_sales_scenarios = [5, 10, 15, 20]  # units per day\n            \n            for daily_sales in daily_sales_scenarios:\n                if daily_sales > 0:\n                    days_to_breakeven = breakeven[\"breakeven_units\"] / daily_sales\n                    breakeven[\"breakeven_timeline\"][f\"{daily_sales}_units_per_day\"] = {\n                        \"days_to_breakeven\": days_to_breakeven,\n                        \"weeks_to_breakeven\": days_to_breakeven / 7,\n                        \"months_to_breakeven\": days_to_breakeven / 30\n                    }\n            \n            return breakeven\n            \n        except Exception as e:\n            self.logger.error(f\"Break-even analysis failed: {e}\")\n            return {\"breakeven_units\": float('inf')}\n    \n    async def _calculate_risk_adjusted_returns(self, profit_analysis: Dict, product_data: Dict) -> Dict[str, Any]:\n        \"\"\"Calculate risk-adjusted returns and financial metrics\"\"\"\n        try:\n            risk_adjusted = {\n                \"risk_factor\": 1.0,\n                \"adjusted_roi\": 0,\n                \"confidence_interval\": {},\n                \"financial_metrics\": {},\n                \"risk_assessment\": {}\n            }\n            \n            # Determine risk factors\n            risk_factors = []\n            \n            # Category risk\n            category = product_data.get(\"category\", \"general\")\n            if category.lower() in [\"electronics\", \"gadgets\"]:\n                risk_factors.append(0.15)  # 15% risk premium for electronics\n            elif category.lower() in [\"fashion\", \"clothing\"]:\n                risk_factors.append(0.25)  # 25% risk premium for fashion\n            else:\n                risk_factors.append(0.10)  # 10% default risk premium\n            \n            # Price point risk\n            selling_price = product_data.get(\"price\", product_data.get(\"current_price\", 0))\n            if selling_price > 2000:\n                risk_factors.append(0.20)  # Higher risk for expensive items\n            elif selling_price < 100:\n                risk_factors.append(0.10)  # Lower absolute risk for cheap items\n            \n            # Seasonality risk\n            risk_factors.append(0.15)  # 15% for seasonal variations\n            \n            # Calculate composite risk factor\n            risk_adjusted[\"risk_factor\"] = 1 + sum(risk_factors)\n            \n            # Adjust ROI for risk\n            base_roi = profit_analysis.get(\"net_margin_percent\", 0)\n            risk_adjusted[\"adjusted_roi\"] = base_roi / risk_adjusted[\"risk_factor\"]\n            \n            # Confidence intervals\n            risk_adjusted[\"confidence_interval\"] = {\n                \"95%\": {\n                    \"lower_bound\": risk_adjusted[\"adjusted_roi\"] * 0.8,\n                    \"upper_bound\": risk_adjusted[\"adjusted_roi\"] * 1.2\n                },\n                \"80%\": {\n                    \"lower_bound\": risk_adjusted[\"adjusted_roi\"] * 0.9,\n                    \"upper_bound\": risk_adjusted[\"adjusted_roi\"] * 1.1\n                }\n            }\n            \n            # Financial metrics\n            risk_adjusted[\"financial_metrics\"] = {\n                \"sharpe_ratio\": self._calculate_sharpe_ratio(base_roi, risk_factors),\n                \"risk_return_ratio\": base_roi / (sum(risk_factors) * 100) if sum(risk_factors) > 0 else 0,\n                \"downside_protection\": max(0, base_roi - 10),  # Minimum 10% buffer\n                \"upside_potential\": base_roi * 1.5  # 50% upside potential\n            }\n            \n            # Risk assessment\n            risk_adjusted[\"risk_assessment\"] = {\n                \"overall_risk\": \"high\" if sum(risk_factors) > 0.4 else \"medium\" if sum(risk_factors) > 0.2 else \"low\",\n                \"primary_risks\": self._identify_primary_risks(product_data, risk_factors),\n                \"mitigation_strategies\": self._suggest_risk_mitigation(product_data, risk_factors)\n            }\n            \n            return risk_adjusted\n            \n        except Exception as e:\n            self.logger.error(f\"Risk-adjusted returns calculation failed: {e}\")\n            return {\"risk_factor\": 1.0, \"adjusted_roi\": 0}\n    \n    async def _generate_financial_recommendations(self, profit_analysis: Dict, roi_projections: Dict, breakeven_analysis: Dict) -> List[Dict[str, Any]]:\n        \"\"\"Generate financial recommendations\"\"\"\n        try:\n            recommendations = []\n            \n            # Profit margin recommendations\n            net_margin = profit_analysis.get(\"net_margin_percent\", 0)\n            \n            if net_margin >= 40:\n                recommendations.append({\n                    \"category\": \"profit_optimization\",\n                    \"priority\": \"low\",\n                    \"recommendation\": \"Excellent profit margins - consider premium positioning\",\n                    \"action\": \"Maintain current pricing strategy and focus on brand building\",\n                    \"impact\": \"Sustained high profitability\"\n                })\n            elif net_margin >= 25:\n                recommendations.append({\n                    \"category\": \"profit_optimization\",\n                    \"priority\": \"medium\",\n                    \"recommendation\": \"Good profit margins - optimize for scale\",\n                    \"action\": \"Increase marketing spend to drive volume\",\n                    \"impact\": \"Higher absolute profits through volume\"\n                })\n            elif net_margin >= 15:\n                recommendations.append({\n                    \"category\": \"cost_optimization\",\n                    \"priority\": \"high\",\n                    \"recommendation\": \"Acceptable margins - focus on cost reduction\",\n                    \"action\": \"Negotiate better supplier terms and optimize operations\",\n                    \"impact\": \"Improved profit margins\"\n                })\n            else:\n                recommendations.append({\n                    \"category\": \"viability_assessment\",\n                    \"priority\": \"critical\",\n                    \"recommendation\": \"Low margins - reassess product viability\",\n                    \"action\": \"Consider alternative products or significantly reduce costs\",\n                    \"impact\": \"Avoid potential losses\"\n                })\n            \n            # ROI recommendations\n            annual_roi = roi_projections.get(\"annual_roi\", 0)\n            \n            if annual_roi >= 100:\n                recommendations.append({\n                    \"category\": \"investment_strategy\",\n                    \"priority\": \"high\",\n                    \"recommendation\": \"Excellent ROI - scale aggressively\",\n                    \"action\": \"Increase inventory investment and marketing spend\",\n                    \"impact\": \"Rapid business growth\"\n                })\n            elif annual_roi >= 50:\n                recommendations.append({\n                    \"category\": \"investment_strategy\",\n                    \"priority\": \"medium\",\n                    \"recommendation\": \"Good ROI - gradual scaling recommended\",\n                    \"action\": \"Steady inventory increases with performance monitoring\",\n                    \"impact\": \"Sustainable growth\"\n                })\n            elif annual_roi >= 25:\n                recommendations.append({\n                    \"category\": \"performance_monitoring\",\n                    \"priority\": \"medium\",\n                    \"recommendation\": \"Moderate ROI - monitor closely\",\n                    \"action\": \"Track performance metrics and optimize incrementally\",\n                    \"impact\": \"Stable returns with improvement potential\"\n                })\n            \n            # Break-even recommendations\n            breakeven_units = breakeven_analysis.get(\"breakeven_units\", float('inf'))\n            \n            if breakeven_units < 100:\n                recommendations.append({\n                    \"category\": \"market_entry\",\n                    \"priority\": \"high\",\n                    \"recommendation\": \"Low break-even point - favorable for market entry\",\n                    \"action\": \"Proceed with confidence, minimal risk\",\n                    \"impact\": \"Quick path to profitability\"\n                })\n            elif breakeven_units < 500:\n                recommendations.append({\n                    \"category\": \"market_entry\",\n                    \"priority\": \"medium\",\n                    \"recommendation\": \"Moderate break-even - manageable entry risk\",\n                    \"action\": \"Ensure adequate marketing to reach break-even volume\",\n                    \"impact\": \"Achievable profitability target\"\n                })\n            else:\n                recommendations.append({\n                    \"category\": \"risk_assessment\",\n                    \"priority\": \"high\",\n                    \"recommendation\": \"High break-even volume - elevated risk\",\n                    \"action\": \"Reassess fixed costs and pricing strategy\",\n                    \"impact\": \"Risk mitigation for sustainable business\"\n                })\n            \n            return recommendations\n            \n        except Exception as e:\n            self.logger.error(f\"Financial recommendations generation failed: {e}\")\n            return []\n    \n    async def _perform_scenario_analysis(self, selling_price: float, costs: Dict, fees_taxes: Dict, shipping: Dict) -> Dict[str, Any]:\n        \"\"\"Perform scenario analysis for different business conditions\"\"\"\n        try:\n            scenarios = {\n                \"price_sensitivity\": {},\n                \"cost_variations\": {},\n                \"volume_scenarios\": {},\n                \"market_conditions\": {}\n            }\n            \n            base_total_costs = costs.get(\"total_cogs\", 0) + fees_taxes.get(\"total_fees_taxes\", 0) + shipping.get(\"total_shipping_costs\", 0)\n            \n            # Price sensitivity analysis\n            price_variations = [-20, -10, -5, 0, 5, 10, 20]  # Percentage changes\n            \n            for variation in price_variations:\n                new_price = selling_price * (1 + variation / 100)\n                new_profit = new_price - base_total_costs\n                new_margin = (new_profit / new_price) * 100 if new_price > 0 else 0\n                \n                scenarios[\"price_sensitivity\"][f\"{variation:+d}%\"] = {\n                    \"price\": new_price,\n                    \"profit_per_unit\": new_profit,\n                    \"margin_percent\": new_margin,\n                    \"volume_impact\": self._estimate_volume_impact(variation)\n                }\n            \n            # Cost variation analysis\n            cost_variations = [-15, -10, -5, 0, 5, 10, 15]  # Percentage changes\n            \n            for variation in cost_variations:\n                new_costs = base_total_costs * (1 + variation / 100)\n                new_profit = selling_price - new_costs\n                new_margin = (new_profit / selling_price) * 100 if selling_price > 0 else 0\n                \n                scenarios[\"cost_variations\"][f\"{variation:+d}%\"] = {\n                    \"total_costs\": new_costs,\n                    \"profit_per_unit\": new_profit,\n                    \"margin_percent\": new_margin\n                }\n            \n            # Volume scenarios\n            volume_scenarios = [0.5, 0.7, 1.0, 1.5, 2.0, 3.0]  # Multipliers\n            base_volume = 30  # Base 30 units per month\n            \n            for multiplier in volume_scenarios:\n                volume = int(base_volume * multiplier)\n                monthly_profit = (selling_price - base_total_costs) * volume\n                \n                scenarios[\"volume_scenarios\"][f\"{multiplier}x\"] = {\n                    \"monthly_volume\": volume,\n                    \"monthly_profit\": monthly_profit,\n                    \"annual_profit\": monthly_profit * 12\n                }\n            \n            # Market condition scenarios\n            scenarios[\"market_conditions\"] = {\n                \"recession\": {\n                    \"price_impact\": -15,  # 15% price reduction\n                    \"volume_impact\": -30,  # 30% volume reduction\n                    \"cost_impact\": 5,      # 5% cost increase\n                    \"description\": \"Economic downturn scenario\"\n                },\n                \"normal\": {\n                    \"price_impact\": 0,\n                    \"volume_impact\": 0,\n                    \"cost_impact\": 0,\n                    \"description\": \"Baseline market conditions\"\n                },\n                \"boom\": {\n                    \"price_impact\": 10,   # 10% price premium\n                    \"volume_impact\": 50,  # 50% volume increase\n                    \"cost_impact\": -5,    # 5% cost reduction (economies of scale)\n                    \"description\": \"Favorable market conditions\"\n                }\n            }\n            \n            return scenarios\n            \n        except Exception as e:\n            self.logger.error(f\"Scenario analysis failed: {e}\")\n            return {}\n    \n    async def _analyze_competitive_pricing(self, product_data: Dict, selling_price: float, profit_analysis: Dict) -> Dict[str, Any]:\n        \"\"\"Analyze competitive pricing strategies\"\"\"\n        try:\n            competitive_pricing = {\n                \"current_position\": {},\n                \"pricing_strategies\": {},\n                \"optimization_opportunities\": {},\n                \"recommendations\": []\n            }\n            \n            # Current position analysis\n            net_margin = profit_analysis.get(\"net_margin_percent\", 0)\n            \n            competitive_pricing[\"current_position\"] = {\n                \"price_point\": selling_price,\n                \"margin_category\": self._categorize_margin(net_margin),\n                \"market_segment\": self._determine_market_segment(selling_price),\n                \"competitiveness\": self._assess_price_competitiveness(selling_price, product_data)\n            }\n            \n            # Pricing strategies\n            competitive_pricing[\"pricing_strategies\"] = {\n                \"penetration_pricing\": {\n                    \"suggested_price\": selling_price * 0.85,\n                    \"margin_impact\": (selling_price * 0.85 - (selling_price - profit_analysis.get(\"net_profit\", 0))) / (selling_price * 0.85) * 100,\n                    \"volume_boost_estimate\": \"30-50%\",\n                    \"suitability\": \"High competition markets\"\n                },\n                \"premium_pricing\": {\n                    \"suggested_price\": selling_price * 1.20,\n                    \"margin_impact\": (selling_price * 1.20 - (selling_price - profit_analysis.get(\"net_profit\", 0))) / (selling_price * 1.20) * 100,\n                    \"volume_impact_estimate\": \"-20 to -30%\",\n                    \"suitability\": \"Unique/high-quality products\"\n                },\n                \"psychological_pricing\": {\n                    \"suggested_prices\": [selling_price * 0.99, selling_price * 1.01],\n                    \"impact\": \"Minimal margin change, potential volume boost\",\n                    \"suitability\": \"Consumer psychology optimization\"\n                }\n            }\n            \n            # Optimization opportunities\n            if net_margin < 15:\n                competitive_pricing[\"optimization_opportunities\"][\"cost_reduction\"] = {\n                    \"priority\": \"high\",\n                    \"potential_savings\": \"5-15% cost reduction possible\",\n                    \"methods\": [\"Supplier negotiation\", \"Process optimization\", \"Volume discounts\"]\n                }\n            \n            if selling_price > 1000:\n                competitive_pricing[\"optimization_opportunities\"][\"bundling\"] = {\n                    \"priority\": \"medium\",\n                    \"strategy\": \"Bundle with complementary products\",\n                    \"benefit\": \"Increase average order value and customer satisfaction\"\n                }\n            \n            # Generate recommendations\n            recommendations = []\n            \n            if net_margin >= 30:\n                recommendations.append(\"Consider premium pricing strategy to maximize profit\")\n            elif net_margin <= 10:\n                recommendations.append(\"Focus on cost optimization before pricing adjustments\")\n            \n            if selling_price % 100 == 0:\n                recommendations.append(\"Consider psychological pricing (e.g., ₹999 instead of ₹1000)\")\n            \n            competitive_pricing[\"recommendations\"] = recommendations\n            \n            return competitive_pricing\n            \n        except Exception as e:\n            self.logger.error(f\"Competitive pricing analysis failed: {e}\")\n            return {}\n    \n    # Helper methods\n    \n    def _categorize_margin(self, margin_percent: float) -> str:\n        \"\"\"Categorize profit margin\"\"\"\n        if margin_percent >= 40:\n            return \"excellent\"\n        elif margin_percent >= 25:\n            return \"good\"\n        elif margin_percent >= 15:\n            return \"acceptable\"\n        elif margin_percent >= 5:\n            return \"poor\"\n        else:\n            return \"unprofitable\"\n    \n    def _estimate_monthly_sales(self, selling_price: float, product_data: Dict) -> int:\n        \"\"\"Estimate monthly sales volume\"\"\"\n        # Base estimation logic\n        if selling_price <= 100:\n            base_sales = np.random.randint(50, 150)\n        elif selling_price <= 500:\n            base_sales = np.random.randint(20, 60)\n        elif selling_price <= 1000:\n            base_sales = np.random.randint(10, 30)\n        else:\n            base_sales = np.random.randint(5, 15)\n        \n        # Category adjustments\n        category = product_data.get(\"category\", \"general\").lower()\n        multipliers = {\n            \"electronics\": 1.2,\n            \"fashion\": 1.4,\n            \"home\": 1.0,\n            \"sports\": 0.8,\n            \"books\": 0.6\n        }\n        \n        return int(base_sales * multipliers.get(category, 1.0))\n    \n    def _calculate_sharpe_ratio(self, returns: float, risk_factors: List[float]) -> float:\n        \"\"\"Calculate Sharpe ratio (simplified)\"\"\"\n        risk_free_rate = 6.0  # 6% risk-free rate (India government bonds)\n        volatility = sum(risk_factors) * 100  # Convert to percentage\n        \n        if volatility > 0:\n            return (returns - risk_free_rate) / volatility\n        else:\n            return 0.0\n    \n    def _identify_primary_risks(self, product_data: Dict, risk_factors: List[float]) -> List[str]:\n        \"\"\"Identify primary risk factors\"\"\"\n        risks = []\n        \n        category = product_data.get(\"category\", \"general\").lower()\n        if category in [\"electronics\", \"gadgets\"]:\n            risks.append(\"Technology obsolescence risk\")\n        \n        selling_price = product_data.get(\"price\", product_data.get(\"current_price\", 0))\n        if selling_price > 2000:\n            risks.append(\"High price point risk\")\n        \n        if sum(risk_factors) > 0.3:\n            risks.append(\"Market volatility risk\")\n        \n        risks.append(\"Currency fluctuation risk\")\n        risks.append(\"Regulatory compliance risk\")\n        \n        return risks\n    \n    def _suggest_risk_mitigation(self, product_data: Dict, risk_factors: List[float]) -> List[str]:\n        \"\"\"Suggest risk mitigation strategies\"\"\"\n        strategies = [\n            \"Diversify product portfolio\",\n            \"Maintain adequate cash reserves\",\n            \"Implement dynamic pricing strategy\",\n            \"Monitor market trends regularly\",\n            \"Build strong supplier relationships\"\n        ]\n        \n        category = product_data.get(\"category\", \"general\").lower()\n        if category in [\"electronics\", \"gadgets\"]:\n            strategies.append(\"Focus on latest models and quick inventory turnover\")\n        \n        return strategies\n    \n    def _estimate_volume_impact(self, price_variation: float) -> str:\n        \"\"\"Estimate volume impact from price changes\"\"\"\n        # Simple price elasticity model\n        elasticity = -1.5  # Assume -1.5 price elasticity\n        volume_change = price_variation * elasticity\n        \n        if volume_change > 15:\n            return \"High volume increase\"\n        elif volume_change > 5:\n            return \"Moderate volume increase\"\n        elif volume_change > -5:\n            return \"Minimal volume impact\"\n        elif volume_change > -15:\n            return \"Moderate volume decrease\"\n        else:\n            return \"Significant volume decrease\"\n    \n    def _determine_market_segment(self, selling_price: float) -> str:\n        \"\"\"Determine market segment based on price\"\"\"\n        if selling_price <= 100:\n            return \"budget\"\n        elif selling_price <= 500:\n            return \"mid_market\"\n        elif selling_price <= 2000:\n            return \"premium\"\n        else:\n            return \"luxury\"\n    \n    def _assess_price_competitiveness(self, selling_price: float, product_data: Dict) -> str:\n        \"\"\"Assess price competitiveness\"\"\"\n        # Simplified assessment based on price point and category\n        category = product_data.get(\"category\", \"general\").lower()\n        \n        # Mock competitive analysis\n        if selling_price <= 200:\n            return \"highly_competitive\"\n        elif selling_price <= 1000:\n            return \"competitive\"\n        else:\n            return \"premium_positioned\"\n    \n    def _calculate_financial_confidence(self, financial_data: Dict) -> float:\n        \"\"\"Calculate confidence level for financial analysis\"\"\"\n        confidence_factors = []\n        \n        # Data completeness\n        has_costs = bool(financial_data.get(\"cost_breakdown\", {}).get(\"total_cogs\"))\n        has_revenue = bool(financial_data.get(\"revenue_analysis\", {}).get(\"projected_monthly_revenue\"))\n        has_profit = bool(financial_data.get(\"profit_analysis\", {}).get(\"net_profit\"))\n        \n        data_completeness = (has_costs + has_revenue + has_profit) / 3\n        confidence_factors.append(data_completeness)\n        \n        # Analysis depth\n        analysis_sections = [\n            \"roi_projections\", \"breakeven_analysis\", \"scenario_analysis\", \n            \"competitive_pricing\", \"risk_adjusted_returns\"\n        ]\n        \n        completed_sections = sum(1 for section in analysis_sections if financial_data.get(section))\n        analysis_depth = completed_sections / len(analysis_sections)\n        confidence_factors.append(analysis_depth)\n        \n        # Margin reasonableness\n        net_margin = financial_data.get(\"profit_analysis\", {}).get(\"net_margin_percent\", 0)\n        if 5 <= net_margin <= 50:  # Reasonable margin range\n            margin_confidence = 1.0\n        elif net_margin > 50 or net_margin < 0:\n            margin_confidence = 0.5  # Questionable margins\n        else:\n            margin_confidence = 0.7  # Low but acceptable margins\n        \n        confidence_factors.append(margin_confidence)\n        \n        return sum(confidence_factors) / len(confidence_factors) if confidence_factors else 0.5