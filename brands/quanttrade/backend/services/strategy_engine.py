"""
Trading Strategy Engine - Base Classes and Implementations
Modular strategy framework with backtesting support
"""
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from datetime import datetime
import pandas as pd
import numpy as np
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """Trading signal generated by a strategy"""
    symbol: str
    side: str  # 'buy' or 'sell'
    signal_strength: float  # 0.0 to 1.0
    price: float
    timestamp: datetime
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class StrategyConfig:
    """Strategy configuration parameters"""
    name: str
    parameters: Dict[str, Any]
    risk_per_trade: float = 0.02
    max_position_size: float = 0.1
    stop_loss_pct: float = 0.02
    take_profit_pct: float = 0.05


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    Provides common functionality and interface
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize strategy with configuration
        
        Args:
            config: Strategy configuration
        """
        self.config = config
        self.name = config.name
        self.parameters = config.parameters
        self.positions: Dict[str, Any] = {}
        self.trade_history: List[Dict] = []
        self.performance_metrics: Dict[str, float] = {}
        
    @abstractmethod
    async def generate_signals(self, market_data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate trading signals based on market data
        
        Args:
            market_data: DataFrame with OHLCV data
            
        Returns:
            List of trading signals
        """
        pass
    
    @abstractmethod
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators
        
        Args:
            data: OHLCV DataFrame
            
        Returns:
            DataFrame with added indicator columns
        """
        pass
    
    def validate_signal(self, signal: TradingSignal) -> bool:
        """
        Validate trading signal against risk parameters
        
        Args:
            signal: Trading signal to validate
            
        Returns:
            True if signal is valid
        """
        # Check signal strength threshold
        if signal.signal_strength < 0.5:
            return False
            
        # Check if we already have a position
        if signal.symbol in self.positions:
            logger.warning(f"Already have position in {signal.symbol}")
            return False
            
        return True
    
    def calculate_position_size(
        self,
        account_balance: float,
        entry_price: float,
        stop_loss_price: float
    ) -> float:
        """
        Calculate position size based on risk management rules
        
        Args:
            account_balance: Current account balance
            entry_price: Entry price
            stop_loss_price: Stop loss price
            
        Returns:
            Position size
        """
        # Calculate risk amount
        risk_amount = account_balance * self.config.risk_per_trade
        
        # Calculate price risk
        price_risk = abs(entry_price - stop_loss_price)
        
        # Calculate position size
        if price_risk > 0:
            position_size = risk_amount / price_risk
        else:
            position_size = 0
            
        # Apply maximum position size limit
        max_size = account_balance * self.config.max_position_size / entry_price
        position_size = min(position_size, max_size)
        
        return position_size
    
    def update_performance(self, trade: Dict):
        """
        Update strategy performance metrics
        
        Args:
            trade: Completed trade dictionary
        """
        self.trade_history.append(trade)
        
        # Calculate basic metrics
        total_trades = len(self.trade_history)
        winning_trades = sum(1 for t in self.trade_history if t.get('pnl', 0) > 0)
        
        self.performance_metrics = {
            'total_trades': total_trades,
            'winning_trades': winning_trades,
            'losing_trades': total_trades - winning_trades,
            'win_rate': winning_trades / total_trades if total_trades > 0 else 0,
            'total_pnl': sum(t.get('pnl', 0) for t in self.trade_history)
        }


class RSIMomentumStrategy(BaseStrategy):
    """
    RSI Momentum Strategy
    Buys on RSI oversold + momentum, sells on RSI overbought
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize RSI Momentum strategy
        
        Default parameters:
            - rsi_period: 14
            - rsi_oversold: 30
            - rsi_overbought: 70
            - momentum_period: 20
        """
        super().__init__(config)
        
        # Set default parameters
        self.rsi_period = self.parameters.get('rsi_period', 14)
        self.rsi_oversold = self.parameters.get('rsi_oversold', 30)
        self.rsi_overbought = self.parameters.get('rsi_overbought', 70)
        self.momentum_period = self.parameters.get('momentum_period', 20)
        
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate RSI and Momentum indicators
        
        Args:
            data: OHLCV DataFrame
            
        Returns:
            DataFrame with RSI and Momentum columns
        """
        df = data.copy()
        
        # Calculate RSI
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=self.rsi_period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=self.rsi_period).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # Calculate Momentum
        df['momentum'] = df['close'].pct_change(periods=self.momentum_period)
        
        # Calculate moving averages for trend confirmation
        df['sma_20'] = df['close'].rolling(window=20).mean()
        df['sma_50'] = df['close'].rolling(window=50).mean()
        
        return df
    
    async def generate_signals(self, market_data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate trading signals based on RSI and Momentum
        
        Args:
            market_data: OHLCV DataFrame
            
        Returns:
            List of trading signals
        """
        signals = []
        
        # Calculate indicators
        df = self.calculate_indicators(market_data)
        
        # Get latest values
        latest = df.iloc[-1]
        symbol = latest.get('symbol', 'UNKNOWN')
        
        # Buy signal: RSI oversold + positive momentum + uptrend
        if (latest['rsi'] < self.rsi_oversold and 
            latest['momentum'] > 0 and
            latest['close'] > latest['sma_20']):
            
            signal_strength = 1 - (latest['rsi'] / 100)  # Lower RSI = stronger signal
            
            signals.append(TradingSignal(
                symbol=symbol,
                side='buy',
                signal_strength=signal_strength,
                price=latest['close'],
                timestamp=latest.get('timestamp', datetime.now()),
                metadata={
                    'rsi': latest['rsi'],
                    'momentum': latest['momentum'],
                    'strategy': 'RSI Momentum'
                }
            ))
        
        # Sell signal: RSI overbought
        elif latest['rsi'] > self.rsi_overbought:
            signal_strength = latest['rsi'] / 100  # Higher RSI = stronger sell signal
            
            signals.append(TradingSignal(
                symbol=symbol,
                side='sell',
                signal_strength=signal_strength,
                price=latest['close'],
                timestamp=latest.get('timestamp', datetime.now()),
                metadata={
                    'rsi': latest['rsi'],
                    'momentum': latest['momentum'],
                    'strategy': 'RSI Momentum'
                }
            ))
        
        return signals


class MeanReversionStrategy(BaseStrategy):
    """
    Mean Reversion Strategy
    Trades based on price deviation from moving average
    """
    
    def __init__(self, config: StrategyConfig):
        """
        Initialize Mean Reversion strategy
        
        Default parameters:
            - ma_period: 20
            - std_dev_threshold: 2.0
            - lookback_period: 50
        """
        super().__init__(config)
        
        self.ma_period = self.parameters.get('ma_period', 20)
        self.std_dev_threshold = self.parameters.get('std_dev_threshold', 2.0)
        self.lookback_period = self.parameters.get('lookback_period', 50)
        
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate Bollinger Bands and Z-Score
        
        Args:
            data: OHLCV DataFrame
            
        Returns:
            DataFrame with indicators
        """
        df = data.copy()
        
        # Calculate moving average
        df['ma'] = df['close'].rolling(window=self.ma_period).mean()
        
        # Calculate standard deviation
        df['std'] = df['close'].rolling(window=self.ma_period).std()
        
        # Calculate Bollinger Bands
        df['upper_band'] = df['ma'] + (df['std'] * self.std_dev_threshold)
        df['lower_band'] = df['ma'] - (df['std'] * self.std_dev_threshold)
        
        # Calculate Z-Score
        df['z_score'] = (df['close'] - df['ma']) / df['std']
        
        # Calculate RSI for confirmation
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        return df
    
    async def generate_signals(self, market_data: pd.DataFrame) -> List[TradingSignal]:
        """
        Generate mean reversion signals
        
        Args:
            market_data: OHLCV DataFrame
            
        Returns:
            List of trading signals
        """
        signals = []
        
        # Calculate indicators
        df = self.calculate_indicators(market_data)
        
        # Get latest values
        latest = df.iloc[-1]
        symbol = latest.get('symbol', 'UNKNOWN')
        
        # Buy signal: Price below lower band (oversold)
        if latest['close'] < latest['lower_band'] and latest['rsi'] < 40:
            signal_strength = min(abs(latest['z_score']) / self.std_dev_threshold, 1.0)
            
            signals.append(TradingSignal(
                symbol=symbol,
                side='buy',
                signal_strength=signal_strength,
                price=latest['close'],
                timestamp=latest.get('timestamp', datetime.now()),
                metadata={
                    'z_score': latest['z_score'],
                    'rsi': latest['rsi'],
                    'distance_from_ma': latest['close'] - latest['ma'],
                    'strategy': 'Mean Reversion'
                }
            ))
        
        # Sell signal: Price above upper band (overbought)
        elif latest['close'] > latest['upper_band'] and latest['rsi'] > 60:
            signal_strength = min(abs(latest['z_score']) / self.std_dev_threshold, 1.0)
            
            signals.append(TradingSignal(
                symbol=symbol,
                side='sell',
                signal_strength=signal_strength,
                price=latest['close'],
                timestamp=latest.get('timestamp', datetime.now()),
                metadata={
                    'z_score': latest['z_score'],
                    'rsi': latest['rsi'],
                    'distance_from_ma': latest['close'] - latest['ma'],
                    'strategy': 'Mean Reversion'
                }
            ))
        
        return signals


class StrategyManager:
    """
    Strategy orchestration and lifecycle management
    Manages multiple strategies and their execution
    """
    
    def __init__(self):
        """Initialize strategy manager"""
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_strategies: List[str] = []
        
    def register_strategy(self, strategy_id: str, strategy: BaseStrategy):
        """
        Register a new strategy
        
        Args:
            strategy_id: Unique strategy identifier
            strategy: Strategy instance
        """
        self.strategies[strategy_id] = strategy
        logger.info(f"Registered strategy: {strategy_id}")
        
    def activate_strategy(self, strategy_id: str):
        """
        Activate a strategy
        
        Args:
            strategy_id: Strategy to activate
        """
        if strategy_id in self.strategies and strategy_id not in self.active_strategies:
            self.active_strategies.append(strategy_id)
            logger.info(f"Activated strategy: {strategy_id}")
            
    def deactivate_strategy(self, strategy_id: str):
        """
        Deactivate a strategy
        
        Args:
            strategy_id: Strategy to deactivate
        """
        if strategy_id in self.active_strategies:
            self.active_strategies.remove(strategy_id)
            logger.info(f"Deactivated strategy: {strategy_id}")
            
    async def generate_all_signals(self, market_data: pd.DataFrame) -> Dict[str, List[TradingSignal]]:
        """
        Generate signals from all active strategies
        
        Args:
            market_data: Market data DataFrame
            
        Returns:
            Dictionary mapping strategy_id to signals
        """
        all_signals = {}
        
        for strategy_id in self.active_strategies:
            strategy = self.strategies[strategy_id]
            signals = await strategy.generate_signals(market_data)
            all_signals[strategy_id] = signals
            
        return all_signals
    
    def get_strategy_performance(self, strategy_id: str) -> Dict[str, Any]:
        """
        Get performance metrics for a strategy
        
        Args:
            strategy_id: Strategy identifier
            
        Returns:
            Performance metrics dictionary
        """
        if strategy_id in self.strategies:
            return self.strategies[strategy_id].performance_metrics
        return {}
